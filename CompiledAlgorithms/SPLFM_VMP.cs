using System;
using MicrosoftResearch.Infer;
using MicrosoftResearch.Infer.Distributions;
using MicrosoftResearch.Infer.Maths;
using MicrosoftResearch.Infer.Collections;
using MicrosoftResearch.Infer.Factors;
using gpnetworkVB;

namespace gpnetworkVB
{
	/// <summary>
	/// Class for performing inference in model 'SPLFM' using algorithm 'VariationalMessagePassing'.
    /// Implementation of the Semi Parametric Latent Factor Model of 
    /// Teh, Y., Seeger, M., and Jordan, M. (AISTATS 2005).
	/// </summary>
	/// <remarks>
	/// The easiest way to use this class is to wrap an instance in a CompiledAlgorithm object and use
	/// the methods on CompiledAlgorithm to set parameters and execute inference.
	/// 
	/// If you instead wish to use this class directly, you must perform the following steps:
	/// 1) Create an instance of the class
	/// 2) Set the value of any externally-set fields e.g. data, priors
	/// 3) Call the Execute(numberOfIterations) method
	/// 4) Use the XXXMarginal() methods to retrieve posterior marginals for different variables.
	/// 
	/// Generated by Infer.NET 2.4 beta 3 at 12:10 on 08 October 2011.
	/// </remarks>
    public class SPLFM_VMP : IGeneratedAlgorithm, IPredictionSPLFMModel
	{
		#region Fields

        public KernelOptimiser nodeKernelOptimiser;

		/// <summary>Field backing the NumberOfIterationsDone property</summary>
		private int numberOfIterationsDone;
		/// <summary>Field backing the D property</summary>
		private int d;
		/// <summary>Field backing the N property</summary>
		private int n;
		/// <summary>Field backing the Q property</summary>
		private int q;
		/// <summary>Field backing the nodeFunctionsInitVar property</summary>
		private IDistribution<Vector[]> NodeFunctionsInitVar;
		/// <summary>Field backing the nodeSignalPrecisionsPrior property</summary>
		private Gamma[] NodeSignalPrecisionsPrior;
		/// <summary>Field backing the K_node_inverse property</summary>
		private PositiveDefiniteMatrix k_node_inverse;
		/// <summary>Field backing the noisePrecisionPrior property</summary>
		private Gamma NoisePrecisionPrior;
		/// <summary>Field backing the observedData property</summary>
		private double[,] ObservedData;
		/// <summary>Field backing the isMissing property</summary>
		private bool[,] IsMissing;
		/// <summary>The number of iterations last computed by Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0. Set this to zero to force re-execution of Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0</summary>
		public int Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone;
		/// <summary>The number of iterations last computed by Constant. Set this to zero to force re-execution of Constant</summary>
		public int Constant_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2. Set this to zero to force re-execution of Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2</summary>
		public int Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_iterationsDone;
		/// <summary>True if Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2 has performed initialisation. Set this to false to force re-execution of Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2</summary>
		public bool Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised;
		/// <summary>The number of iterations last computed by Changed_N. Set this to zero to force re-execution of Changed_N</summary>
		public int Changed_N_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_N_D. Set this to zero to force re-execution of Changed_N_D</summary>
		public int Changed_N_D_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_N_D_Q. Set this to zero to force re-execution of Changed_N_D_Q</summary>
		public int Changed_N_D_Q_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6. Set this to zero to force re-execution of Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6</summary>
		public int Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone;
		/// <summary>True if Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6 has performed initialisation. Set this to false to force re-execution of Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6</summary>
		public bool Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised;
		/// <summary>The number of iterations last computed by Changed_D_Q. Set this to zero to force re-execution of Changed_D_Q</summary>
		public int Changed_D_Q_iterationsDone;
		/// <summary>The number of iterations last computed by Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8. Set this to zero to force re-execution of Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8</summary>
		public int Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_iterationsDone;
		/// <summary>True if Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8 has performed initialisation. Set this to false to force re-execution of Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8</summary>
		public bool Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised;
		public DistributionStructArray<Gaussian,double>[][] temp_B;
		/// <summary>Message to marginal of 'nodeFunctions'</summary>
		public DistributionRefArray<VectorGaussian,Vector> nodeFunctions_marginal_F;
		/// <summary>Message to use of 'nodeFunctions'</summary>
		public DistributionRefArray<VectorGaussian,Vector> nodeFunctions_use_F;
		/// <summary>Message from use of 'weights'</summary>
		public DistributionStructArray2D<Gaussian,double> weights_use_B;
		/// <summary>Message to marginal of 'ev'</summary>
		public Bernoulli ev_marginal_F;
		/// <summary>Message to marginal of 'nodeSignalPrecisions'</summary>
		public DistributionStructArray<Gamma,double> nodeSignalPrecisions_marginal_F;
		/// <summary>Message to marginal of 'weights'</summary>
		public DistributionStructArray2D<Gaussian,double> weights_marginal_F;
		public DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]> nodeFunctionValues_F;
		public DistributionStructArray2D<Gaussian,double> noiseLessY_F;
		/// <summary>Message to marginal of 'noisePrecision'</summary>
		public Gamma noisePrecision_marginal_F;
		public DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]> nodeFunctionValuesPredictive_F;
		#endregion

		#region Properties
		/// <summary>The number of iterations done from the initial state</summary>
		public int NumberOfIterationsDone
		{			get {
				return this.numberOfIterationsDone;
			}
		}

		/// <summary>The externally-specified value of 'D'</summary>
		public int D
		{			get {
				return this.d;
			}
			set {
				if (this.d!=value) {
					this.d = value;
					this.numberOfIterationsDone = 0;
					this.Changed_N_D_iterationsDone = 0;
					this.Changed_N_D_Q_iterationsDone = 0;
					this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone = 0;
					this.Changed_D_Q_iterationsDone = 0;
					this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_iterationsDone = 0;
					this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'N'</summary>
		public int N
		{			get {
				return this.n;
			}
			set {
				if (this.n!=value) {
					this.n = value;
					this.numberOfIterationsDone = 0;
					this.Changed_N_iterationsDone = 0;
					this.Changed_N_D_iterationsDone = 0;
					this.Changed_N_D_Q_iterationsDone = 0;
					this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone = 0;
					this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = false;
					this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'Q'</summary>
		public int Q
		{			get {
				return this.q;
			}
			set {
				if (this.q!=value) {
					this.q = value;
					this.numberOfIterationsDone = 0;
					this.Changed_N_D_Q_iterationsDone = 0;
					this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone = 0;
					this.Changed_D_Q_iterationsDone = 0;
					this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_iterationsDone = 0;
					this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'nodeFunctionsInitVar'</summary>
		public IDistribution<Vector[]> nodeFunctionsInitVar
		{			get {
				return this.NodeFunctionsInitVar;
			}
			set {
				this.NodeFunctionsInitVar = value;
				this.numberOfIterationsDone = 0;
				this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised = false;
				this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = false;
				this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_iterationsDone = 0;
				this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
			}
		}

		/// <summary>The externally-specified value of 'nodeSignalPrecisionsPrior'</summary>
		public Gamma[] nodeSignalPrecisionsPrior
		{			get {
				return this.NodeSignalPrecisionsPrior;
			}
			set {
				if ((value!=null)&&(value.Length!=this.q)) {
					throw new ArgumentException(((("Provided array of length "+value.Length)+" when length ")+this.q)+" was expected for variable \'nodeSignalPrecisionsPrior\'");
				}
				this.NodeSignalPrecisionsPrior = value;
				this.numberOfIterationsDone = 0;
				this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised = false;
				this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = false;
				this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
			}
		}

		/// <summary>The externally-specified value of 'K_node_inverse'</summary>
		public PositiveDefiniteMatrix K_node_inverse
		{			get {
				return this.k_node_inverse;
			}
			set {
				this.k_node_inverse = value;
				this.numberOfIterationsDone = 0;
				this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised = false;
				this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = false;
				this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
			}
		}

		/// <summary>The externally-specified value of 'noisePrecisionPrior'</summary>
		public Gamma noisePrecisionPrior
		{			get {
				return this.NoisePrecisionPrior;
			}
			set {
				if (this.NoisePrecisionPrior!=value) {
					this.NoisePrecisionPrior = value;
					this.numberOfIterationsDone = 0;
					this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised = false;
					this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = false;
					this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
					this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'observedData'</summary>
		public double[,] observedData
		{			get {
				return this.ObservedData;
			}
			set {
				if ((value!=null)&&(((value.GetLength(0))!=this.d)||((value.GetLength(1))!=this.n))) {
					throw new ArgumentException(((("Provided array of size "+(((("("+(value.GetLength(0)))+",")+(value.GetLength(1)))+")"))+" when size ")+(((("("+this.d)+",")+this.n)+")"))+" was expected");
				}
				this.ObservedData = value;
				this.numberOfIterationsDone = 0;
				this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised = false;
				this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = false;
				this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
			}
		}

		/// <summary>The externally-specified value of 'isMissing'</summary>
		public bool[,] isMissing
		{			get {
				return this.IsMissing;
			}
			set {
				if ((value!=null)&&(((value.GetLength(0))!=this.d)||((value.GetLength(1))!=this.n))) {
					throw new ArgumentException(((("Provided array of size "+(((("("+(value.GetLength(0)))+",")+(value.GetLength(1)))+")"))+" when size ")+(((("("+this.d)+",")+this.n)+")"))+" was expected");
				}
				this.IsMissing = value;
				this.numberOfIterationsDone = 0;
				this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised = false;
				this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = false;
				this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
			}
		}

		#endregion

		#region Methods
		/// <summary>Get the observed value of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		public object GetObservedValue(string variableName)
		{
			if (variableName=="D") {
				return this.D;
			}
			if (variableName=="N") {
				return this.N;
			}
			if (variableName=="Q") {
				return this.Q;
			}
			if (variableName=="nodeFunctionsInitVar") {
				return this.nodeFunctionsInitVar;
			}
			if (variableName=="nodeSignalPrecisionsPrior") {
				return this.nodeSignalPrecisionsPrior;
			}
			if (variableName=="K_node_inverse") {
				return this.K_node_inverse;
			}
			if (variableName=="noisePrecisionPrior") {
				return this.noisePrecisionPrior;
			}
			if (variableName=="observedData") {
				return this.observedData;
			}
			if (variableName=="isMissing") {
				return this.isMissing;
			}
			throw new ArgumentException("Not an observed variable name: "+variableName);
		}

		/// <summary>Set the observed value of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		/// <param name="value">Observed value</param>
		public void SetObservedValue(string variableName, object value)
		{
			if (variableName=="D") {
				this.D = (int)value;
				return ;
			}
			if (variableName=="N") {
				this.N = (int)value;
				return ;
			}
			if (variableName=="Q") {
				this.Q = (int)value;
				return ;
			}
			if (variableName=="nodeFunctionsInitVar") {
				this.nodeFunctionsInitVar = (IDistribution<Vector[]>)value;
				return ;
			}
			if (variableName=="nodeSignalPrecisionsPrior") {
				this.nodeSignalPrecisionsPrior = (Gamma[])value;
				return ;
			}
			if (variableName=="K_node_inverse") {
				this.K_node_inverse = (PositiveDefiniteMatrix)value;
				return ;
			}
			if (variableName=="noisePrecisionPrior") {
				this.noisePrecisionPrior = (Gamma)value;
				return ;
			}
			if (variableName=="observedData") {
				this.observedData = (double[,])value;
				return ;
			}
			if (variableName=="isMissing") {
				this.isMissing = (bool[,])value;
				return ;
			}
			throw new ArgumentException("Not an observed variable name: "+variableName);
		}

		/// <summary>The marginal distribution of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		public object Marginal(string variableName)
		{
			if (variableName=="ev") {
				return this.EvMarginal();
			}
			if (variableName=="weights") {
				return this.WeightsMarginal();
			}
			if (variableName=="nodeSignalPrecisions") {
				return this.NodeSignalPrecisionsMarginal();
			}
			if (variableName=="nodeFunctionValues") {
				return this.NodeFunctionValuesMarginal();
			}
			if (variableName=="noiseLessY") {
				return this.NoiseLessYMarginal();
			}
			if (variableName=="noisePrecision") {
				return this.NoisePrecisionMarginal();
			}
			if (variableName=="nodeFunctionValuesPredictive") {
				return this.NodeFunctionValuesPredictiveMarginal();
			}
			throw new ArgumentException("This class was not built to infer "+variableName);
		}

		public T Marginal<T>(string variableName)
		{
			return Distribution.ChangeType<T>(this.Marginal(variableName));
		}

		/// <summary>The query-specific marginal distribution of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		/// <param name="query">QueryType name. For example, GibbsSampling answers 'Marginal', 'Samples', and 'Conditionals' queries</param>
		public object Marginal(string variableName, string query)
		{
			if (query=="Marginal") {
				return this.Marginal(variableName);
			}
			throw new ArgumentException(((("This class was not built to infer \'"+variableName)+"\' with query \'")+query)+"\'");
		}

		public T Marginal<T>(string variableName, string query)
		{
			return Distribution.ChangeType<T>(this.Marginal(variableName, query));
		}

		/// <summary>The output message of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		public object GetOutputMessage(string variableName)
		{
			throw new ArgumentException("This class was not built to compute an output message for "+variableName);
		}

		/// <summary>Update all marginals, by iterating message passing the given number of times</summary>
		/// <param name="numberOfIterations">The number of times to iterate each loop</param>
		/// <param name="initialise">If true, messages that initialise loops are reset when observed values change</param>
		private void Execute(int numberOfIterations, bool initialise)
		{
			if (numberOfIterations<this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone) {
				this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised = false;
				this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = false;
				this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = false;
				this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
			}
			this.Changed_N();
			this.Changed_N_D();
			this.Changed_N_D_Q();
			this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6(initialise);
			this.Constant();
			this.Changed_D_Q();
			this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8(initialise);
			this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2(initialise);
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0(numberOfIterations);
			this.numberOfIterationsDone = numberOfIterations;
		}

		public void Execute(int numberOfIterations)
		{
			this.Execute(numberOfIterations, true);
		}

		public void Update(int additionalIterations)
		{
			this.Execute(this.numberOfIterationsDone+additionalIterations, false);
		}

		private void OnProgressChanged(ProgressChangedEventArgs e)
		{
			// Make a temporary copy of the event to avoid a race condition
			// if the last subscriber unsubscribes immediately after the null check and before the event is raised.
			EventHandler<ProgressChangedEventArgs> handler = this.ProgressChanged;
			if (handler!=null) {
				handler(this, e);
			}
		}

		/// <summary>Reset all messages to their initial values.  Sets NumberOfIterationsDone to 0.</summary>
		public void Reset()
		{
			this.Execute(0);
		}

		/// <summary>Computations that depend on the observed value of N</summary>
		public void Changed_N()
		{
			if (this.Changed_N_iterationsDone==1) {
				return ;
			}
			// Create array for replicates of 'temp_B'
			this.temp_B = new DistributionStructArray<Gaussian,double>[this.n][];
			this.Changed_N_iterationsDone = 1;
			this.Changed_N_D_iterationsDone = 0;
			this.Changed_N_D_Q_iterationsDone = 0;
			this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone = 0;
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of N and D</summary>
		public void Changed_N_D()
		{
			if (this.Changed_N_D_iterationsDone==1) {
				return ;
			}
			for(int n = 0; n<N; n++) {
				// Create array for replicates of 'temp_B'
				this.temp_B[n] = new DistributionStructArray<Gaussian,double>[this.d];
			}
			this.Changed_N_D_iterationsDone = 1;
			this.Changed_N_D_Q_iterationsDone = 0;
			this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone = 0;
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of N and D and Q</summary>
		public void Changed_N_D_Q()
		{
			if (this.Changed_N_D_Q_iterationsDone==1) {
				return ;
			}
			for(int n = 0; n<N; n++) {
				for(int d = 0; d<D; d++) {
					// Create array for 'temp' Backwards messages.
					this.temp_B[n][d] = new DistributionStructArray<Gaussian,double>(this.q);
				}
			}
			this.Changed_N_D_Q_iterationsDone = 1;
			this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone = 0;
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of N and D and Q and must reset on changes to numberOfIterationsDecreased and isMissing and observedData and noisePrecisionPrior and K_node_inverse and nodeSignalPrecisionsPrior and nodeFunctionsInitVar</summary>
		/// <param name="initialise">If true, reset messages that initialise loops</param>
		public void Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6(bool initialise)
		{
			if ((this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone==1)&&((!initialise)||this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised)) {
				return ;
			}
			for(int n = 0; n<N; n++) {
				for(int d = 0; d<D; d++) {
					for(int q = 0; q<Q; q++) {
						this.temp_B[n][d][q] = ArrayHelper.MakeUniform<Gaussian>(Gaussian.Uniform());
					}
				}
			}
			this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_iterationsDone = 1;
			this.Changed_N_D_Q_Init_numberOfIterationsDecreased_isMissing_observedData_noisePrecisionPrior_K_node_inv6_isInitialised = true;
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
		}

		/// <summary>Computations that do not depend on observed values</summary>
		public void Constant()
		{
			if (this.Constant_iterationsDone==1) {
				return ;
			}
			this.Constant_iterationsDone = 1;
			this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_iterationsDone = 0;
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
			this.Changed_D_Q_iterationsDone = 0;
			this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of D and Q</summary>
		public void Changed_D_Q()
		{
			if (this.Changed_D_Q_iterationsDone==1) {
				return ;
			}
			// Create array for 'weights_use' Backwards messages.
			this.weights_use_B = new DistributionStructArray2D<Gaussian,double>(this.d, this.q);
			this.Changed_D_Q_iterationsDone = 1;
			this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_iterationsDone = 0;
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of D and Q and must reset on changes to numberOfIterationsDecreased and N and isMissing and observedData and noisePrecisionPrior and K_node_inverse and nodeSignalPrecisionsPrior and nodeFunctionsInitVar</summary>
		/// <param name="initialise">If true, reset messages that initialise loops</param>
		public void Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8(bool initialise)
		{
			if ((this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_iterationsDone==1)&&((!initialise)||this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised)) {
				return ;
			}
			for(int d = 0; d<D; d++) {
				for(int q = 0; q<Q; q++) {
					this.weights_use_B[d, q] = ArrayHelper.MakeUniform<Gaussian>(Gaussian.Uniform());
				}
			}
			this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_iterationsDone = 1;
			this.Changed_D_Q_Init_numberOfIterationsDecreased_N_isMissing_observedData_noisePrecisionPrior_K_node_inv8_isInitialised = true;
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of nodeFunctionsInitVar and must reset on changes to numberOfIterationsDecreased and Q and N and D and isMissing and observedData and noisePrecisionPrior and K_node_inverse and nodeSignalPrecisionsPrior</summary>
		/// <param name="initialise">If true, reset messages that initialise loops</param>
		public void Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2(bool initialise)
		{
			if ((this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_iterationsDone==1)&&((!initialise)||this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised)) {
				return ;
			}
			// Create array for 'nodeFunctions_marginal' Forwards messages.
			this.nodeFunctions_marginal_F = ArrayHelper.MakeCopy<DistributionRefArray<VectorGaussian,Vector>>((DistributionRefArray<VectorGaussian,Vector>)this.NodeFunctionsInitVar);
			// Create array for 'nodeFunctions_use' Forwards messages.
			this.nodeFunctions_use_F = ArrayHelper.MakeCopy<DistributionRefArray<VectorGaussian,Vector>>((DistributionRefArray<VectorGaussian,Vector>)this.NodeFunctionsInitVar);
			this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_iterationsDone = 1;
			this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrec2_isInitialised = true;
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = 0;
		}

		/// <summary>Computations that depend on the observed value of numberOfIterationsDecreased and Q and N and D and isMissing and observedData and noisePrecisionPrior and K_node_inverse and nodeSignalPrecisionsPrior and nodeFunctionsInitVar</summary>
		/// <param name="numberOfIterations">The number of times to iterate each loop</param>
		public void Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0(int numberOfIterations)
		{
			if (this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone==numberOfIterations) {
				return ;
			}
			// The constant 'vBernoulli0'
			Bernoulli vBernoulli0 = Bernoulli.FromLogOdds(0);
			this.ev_marginal_F = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
			Gaussian _hoist0 = default(Gaussian);
			for(int q = 0; q<Q; q++) {
				for(int d = 0; d<D; d++) {
					_hoist0 = ArrayHelper.MakeUniform<Gaussian>(Gaussian.Uniform());
					q = this.q-1;
					d = this.d-1;
				}
			}
			_hoist0 = GaussianOp.SampleAverageLogarithm(0, 1);
			// Buffer for VectorGaussianScaledPrecisionOp.SampleMean
			// Create array for replicates of 'nodeFunctions_B_q__SampleVariance'
			PositiveDefiniteMatrix[] nodeFunctions_B_q__SampleVariance = new PositiveDefiniteMatrix[this.q];
			for(int q = 0; q<Q; q++) {
				// Message to 'ev_selector_cases_0_rep4_uses' from VectorGaussianScaled factor
				nodeFunctions_B_q__SampleVariance[q] = VectorGaussianScaledPrecisionOp.SampleVarianceInit(this.nodeFunctions_marginal_F[q]);
			}
			// Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
			// Create array for replicates of 'nodeFunctions_B_q__SampleMean'
			Vector[] nodeFunctions_B_q__SampleMean = new Vector[this.q];
			for(int q = 0; q<Q; q++) {
				// Message to 'ev_selector_cases_0_rep4_uses' from VectorGaussianScaled factor
				nodeFunctions_B_q__SampleMean[q] = VectorGaussianScaledPrecisionOp.SampleMeanInit(this.nodeFunctions_marginal_F[q]);
			}
			// Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
			// Create array for replicates of 'nodeFunctions_B_q__SampleMean_ESamplePrecisionSample'
			double[] nodeFunctions_B_q__SampleMean_ESamplePrecisionSample = new double[this.q];
			// Message from use of 'nodeSignalPrecisions'
			DistributionStructArray<Gamma,double> nodeSignalPrecisions_use_B = default(DistributionStructArray<Gamma,double>);
			// Create array for 'nodeSignalPrecisions_use' Backwards messages.
			nodeSignalPrecisions_use_B = new DistributionStructArray<Gamma,double>(this.q);
			for(int q = 0; q<Q; q++) {
				nodeSignalPrecisions_use_B[q] = ArrayHelper.MakeUniform<Gamma>(this.NodeSignalPrecisionsPrior[q]);
			}
			// Create array for 'nodeSignalPrecisions_marginal' Forwards messages.
			this.nodeSignalPrecisions_marginal_F = new DistributionStructArray<Gamma,double>(this.q);
			for(int q = 0; q<Q; q++) {
				this.nodeSignalPrecisions_marginal_F[q] = ArrayHelper.MakeUniform<Gamma>(this.NodeSignalPrecisionsPrior[q]);
			}
			DistributionRefArray<VectorGaussian,Vector> nodeFunctions_F = default(DistributionRefArray<VectorGaussian,Vector>);
			// Create array for 'nodeFunctions' Forwards messages.
			nodeFunctions_F = new DistributionRefArray<VectorGaussian,Vector>(this.q);
			for(int q = 0; q<Q; q++) {
				nodeFunctions_F[q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
			}
			// Create array for replicates of 'temp_F'
			DistributionStructArray<Gaussian,double>[][] temp_F = new DistributionStructArray<Gaussian,double>[this.n][];
			for(int n = 0; n<N; n++) {
				// Create array for replicates of 'temp_F'
				temp_F[n] = new DistributionStructArray<Gaussian,double>[this.d];
				for(int d = 0; d<D; d++) {
					// Create array for 'temp' Forwards messages.
					temp_F[n][d] = new DistributionStructArray<Gaussian,double>(this.q);
					for(int q = 0; q<Q; q++) {
						temp_F[n][d][q] = ArrayHelper.MakeUniform<Gaussian>(Gaussian.Uniform());
					}
				}
			}
			// Create array for 'weights_marginal' Forwards messages.
			this.weights_marginal_F = new DistributionStructArray2D<Gaussian,double>(this.d, this.q);
			for(int d = 0; d<D; d++) {
				for(int q = 0; q<Q; q++) {
					this.weights_marginal_F[d, q] = ArrayHelper.MakeUniform<Gaussian>(Gaussian.Uniform());
				}
			}
			// Create array for 'nodeFunctionValues' Forwards messages.
			this.nodeFunctionValues_F = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.q);
			for(int q = 0; q<Q; q++) {
				// Create array for 'nodeFunctionValues' Forwards messages.
				this.nodeFunctionValues_F[q] = new DistributionStructArray<Gaussian,double>(this.n);
				for(int _iv0 = 0; _iv0<N; _iv0++) {
					this.nodeFunctionValues_F[q][_iv0] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
				}
			}
			// Create array for 'noiseLessY' Forwards messages.
			this.noiseLessY_F = new DistributionStructArray2D<Gaussian,double>(this.d, this.n);
			for(int d = 0; d<D; d++) {
				for(int n = 0; n<N; n++) {
					this.noiseLessY_F[d, n] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
				}
			}
			// Create array for replicates of 'noisePrecision_cond_isMissing_d__n__1_B'
			Gamma[][] noisePrecision_cond_isMissing_d__n__1_B = new Gamma[this.n][];
			for(int n = 0; n<N; n++) {
				// Create array for replicates of 'noisePrecision_cond_isMissing_d__n__1_B'
				noisePrecision_cond_isMissing_d__n__1_B[n] = new Gamma[this.d];
				for(int d = 0; d<D; d++) {
					if (!this.IsMissing[d, n]) {
						noisePrecision_cond_isMissing_d__n__1_B[n][d] = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
					}
				}
			}
			// Create array for replicates of 'noisePrecision_rep0_rep0_B'
			DistributionStructArray<Gamma,double>[] noisePrecision_rep0_rep0_B = new DistributionStructArray<Gamma,double>[this.n];
			for(int n = 0; n<N; n++) {
				// Create array for 'noisePrecision_rep0_rep0' Backwards messages.
				noisePrecision_rep0_rep0_B[n] = new DistributionStructArray<Gamma,double>(this.d);
				for(int d = 0; d<D; d++) {
					noisePrecision_rep0_rep0_B[n][d] = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
				}
			}
			DistributionStructArray<Gamma,double> noisePrecision_rep0_B = default(DistributionStructArray<Gamma,double>);
			// Create array for 'noisePrecision_rep0' Backwards messages.
			noisePrecision_rep0_B = new DistributionStructArray<Gamma,double>(this.n);
			for(int n = 0; n<N; n++) {
				noisePrecision_rep0_B[n] = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
			}
			// Message from use of 'noisePrecision'
			Gamma noisePrecision_use_B = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
			this.noisePrecision_marginal_F = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
			// Create array for replicates of 'noiseLessY_d_n_cond_isMissing_d__n__1_B'
			Gaussian[][] noiseLessY_d_n_cond_isMissing_d__n__1_B = new Gaussian[this.n][];
			for(int n = 0; n<N; n++) {
				// Create array for replicates of 'noiseLessY_d_n_cond_isMissing_d__n__1_B'
				noiseLessY_d_n_cond_isMissing_d__n__1_B[n] = new Gaussian[this.d];
				for(int d = 0; d<D; d++) {
					if (!this.IsMissing[d, n]) {
						noiseLessY_d_n_cond_isMissing_d__n__1_B[n][d] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
					}
				}
			}
			// Message from use of 'noiseLessY'
			DistributionStructArray2D<Gaussian,double> noiseLessY_use_B = default(DistributionStructArray2D<Gaussian,double>);
			// Create array for 'noiseLessY_use' Backwards messages.
			noiseLessY_use_B = new DistributionStructArray2D<Gaussian,double>(this.d, this.n);
			for(int d = 0; d<D; d++) {
				for(int n = 0; n<N; n++) {
					noiseLessY_use_B[d, n] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
				}
			}
			// Create array for replicates of 'nodeFunctionValues_rep0_B'
			DistributionStructArray<Gaussian,double>[][] nodeFunctionValues_rep0_B = new DistributionStructArray<Gaussian,double>[this.q][];
			for(int q = 0; q<Q; q++) {
				// Create array for replicates of 'nodeFunctionValues_rep0_B'
				nodeFunctionValues_rep0_B[q] = new DistributionStructArray<Gaussian,double>[this.n];
				for(int n = 0; n<N; n++) {
					// Create array for 'nodeFunctionValues_rep0' Backwards messages.
					nodeFunctionValues_rep0_B[q][n] = new DistributionStructArray<Gaussian,double>(this.d);
					for(int d = 0; d<D; d++) {
						nodeFunctionValues_rep0_B[q][n][d] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
					}
				}
			}
			// Message from use of 'nodeFunctionValues'
			DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]> nodeFunctionValues_use_B = default(DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>);
			// Create array for 'nodeFunctionValues_use' Backwards messages.
			nodeFunctionValues_use_B = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.q);
			for(int q = 0; q<Q; q++) {
				// Create array for 'nodeFunctionValues_use' Backwards messages.
				nodeFunctionValues_use_B[q] = new DistributionStructArray<Gaussian,double>(this.n);
				for(int _iv0 = 0; _iv0<N; _iv0++) {
					nodeFunctionValues_use_B[q][_iv0] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
				}
			}
			// Messages from use of 'nodeFunctions'
			DistributionRefArray<VectorGaussian,Vector>[] nodeFunctions_use_uses_B = default(DistributionRefArray<VectorGaussian,Vector>[]);
			// Create array for 'nodeFunctions_use_uses' Backwards messages.
			nodeFunctions_use_uses_B = new DistributionRefArray<VectorGaussian,Vector>[2];
			for(int _ind = 0; _ind<2; _ind++) {
				// Create array for 'nodeFunctions_use_uses' Backwards messages.
				nodeFunctions_use_uses_B[_ind] = new DistributionRefArray<VectorGaussian,Vector>(this.q);
				for(int q = 0; q<Q; q++) {
                    nodeFunctions_use_uses_B[_ind][q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
				}
			}
			// Message from use of 'nodeFunctions'
			DistributionRefArray<VectorGaussian,Vector> nodeFunctions_use_B = default(DistributionRefArray<VectorGaussian,Vector>);
			// Create array for 'nodeFunctions_use' Backwards messages.
			nodeFunctions_use_B = new DistributionRefArray<VectorGaussian,Vector>(this.q);
			for(int q = 0; q<Q; q++) {
                nodeFunctions_use_B[q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
			}
			DistributionRefArray<DistributionStructArray2D<Gaussian,double>,double[,]> weights_rep0_B = default(DistributionRefArray<DistributionStructArray2D<Gaussian,double>,double[,]>);
			// Create array for 'weights_rep0' Backwards messages.
			weights_rep0_B = new DistributionRefArray<DistributionStructArray2D<Gaussian,double>,double[,]>(this.n);
			for(int n = 0; n<N; n++) {
				// Create array for 'weights_rep0' Backwards messages.
				weights_rep0_B[n] = new DistributionStructArray2D<Gaussian,double>(this.d, this.q);
				for(int d = 0; d<D; d++) {
					for(int q = 0; q<Q; q++) {
						weights_rep0_B[n][d, q] = ArrayHelper.MakeUniform<Gaussian>(Gaussian.Uniform());
					}
				}
			}
			for(int q = 0; q<Q; q++) {
				// Message to 'nodeFunctionValues' from ArrayFromVector factor
				this.nodeFunctionValues_F[q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian,double>>(this.nodeFunctions_use_F[q], this.nodeFunctionValues_F[q]);
			}
			// Message to 'noisePrecision_marginal' from Variable factor
			this.noisePrecision_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Gamma>(noisePrecision_use_B, this.NoisePrecisionPrior, this.noisePrecision_marginal_F);
			for(int n = 0; n<N; n++) {
				for(int d = 0; d<D; d++) {
					if (!this.IsMissing[d, n]) {
						// Message to 'noiseLessY_d_n_cond_isMissing_d__n__1' from Gaussian factor
						noiseLessY_d_n_cond_isMissing_d__n__1_B[n][d] = GaussianOp.MeanAverageLogarithm(this.ObservedData[d, n], this.noisePrecision_marginal_F);
						// Message to 'noiseLessY_use' from Copy factor
						noiseLessY_use_B[d, n] = Factor.Copy<Gaussian>(noiseLessY_d_n_cond_isMissing_d__n__1_B[n][d]);
					}
				}
			}
			for(int q = 0; q<Q; q++) {
				for(int d = 0; d<D; d++) {
					// Message to 'weights_marginal' from Variable factor
					this.weights_marginal_F[d, q] = VariableVmpOp.MarginalAverageLogarithm<Gaussian>(this.weights_use_B[d, q], _hoist0, this.weights_marginal_F[d, q]);
				}
			}
			for(int iteration = this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone; iteration<numberOfIterations; iteration++) {
				for(int q = 0; q<Q; q++) {
					// Message to 'nodeFunctionValues' from ArrayFromVector factor
					this.nodeFunctionValues_F[q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian,double>>(this.nodeFunctions_use_F[q], this.nodeFunctionValues_F[q]);
					for(int n = 0; n<N; n++) {
						for(int d = 0; d<D; d++) {
							// Message to 'temp' from Product factor
							temp_F[n][d][q] = GaussianProductVmpOp.ProductAverageLogarithm(this.weights_marginal_F[d, q], this.nodeFunctionValues_F[q][n]);
						}
					}
				}
				for(int n = 0; n<N; n++) {
					for(int d = 0; d<D; d++) {
						// Message to 'noiseLessY' from Sum factor
						this.noiseLessY_F[d, n] = FastSumOp.SumAverageLogarithm(temp_F[n][d]);
						if (!this.IsMissing[d, n]) {
							// Message to 'noisePrecision_cond_isMissing_d__n__1' from Gaussian factor
							noisePrecision_cond_isMissing_d__n__1_B[n][d] = GaussianOp.PrecisionAverageLogarithm(this.ObservedData[d, n], this.noiseLessY_F[d, n]);
							// Message to 'noisePrecision_rep0_rep0' from Copy factor
							noisePrecision_rep0_rep0_B[n][d] = Factor.Copy<Gamma>(noisePrecision_cond_isMissing_d__n__1_B[n][d]);
						}
					}
					// Message to 'noisePrecision_rep0' from Replicate factor
					noisePrecision_rep0_B[n] = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep0_rep0_B[n], noisePrecision_rep0_B[n]);
				}
				// Message to 'noisePrecision_use' from Replicate factor
				noisePrecision_use_B = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep0_B, noisePrecision_use_B);
				// Message to 'noisePrecision_marginal' from Variable factor
				this.noisePrecision_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Gamma>(noisePrecision_use_B, this.NoisePrecisionPrior, this.noisePrecision_marginal_F);
				for(int n = 0; n<N; n++) {
					for(int d = 0; d<D; d++) {
						if (!this.IsMissing[d, n]) {
							// Message to 'noiseLessY_d_n_cond_isMissing_d__n__1' from Gaussian factor
							noiseLessY_d_n_cond_isMissing_d__n__1_B[n][d] = GaussianOp.MeanAverageLogarithm(this.ObservedData[d, n], this.noisePrecision_marginal_F);
							// Message to 'noiseLessY_use' from Copy factor
							noiseLessY_use_B[d, n] = Factor.Copy<Gaussian>(noiseLessY_d_n_cond_isMissing_d__n__1_B[n][d]);
						}
						// Message to 'temp' from Sum factor
						this.temp_B[n][d] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian,double>>(noiseLessY_use_B[d, n], temp_F[n][d], this.temp_B[n][d]);
						for(int q = 0; q<Q; q++) {
							// Message to 'weights_rep0' from Product factor
							weights_rep0_B[n][d, q] = GaussianProductVmpOp.AAverageLogarithm(this.temp_B[n][d][q], this.nodeFunctionValues_F[q][n]);
						}
					}
				}
				// Message to 'weights_use' from Replicate factor
				this.weights_use_B = ReplicateOp.DefAverageLogarithm<DistributionStructArray2D<Gaussian,double>>(weights_rep0_B, this.weights_use_B);
				for(int q = 0; q<Q; q++) {
					for(int d = 0; d<D; d++) {
						// Message to 'weights_marginal' from Variable factor
						this.weights_marginal_F[d, q] = VariableVmpOp.MarginalAverageLogarithm<Gaussian>(this.weights_use_B[d, q], _hoist0, this.weights_marginal_F[d, q]);
						for(int n = 0; n<N; n++) {
							// Message to 'temp' from Product factor
							temp_F[n][d][q] = GaussianProductVmpOp.ProductAverageLogarithm(this.weights_marginal_F[d, q], this.nodeFunctionValues_F[q][n]);
						}
					}
				}
				for(int n = 0; n<N; n++) {
					for(int d = 0; d<D; d++) {
						// Message to 'temp' from Sum factor
						this.temp_B[n][d] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian,double>>(noiseLessY_use_B[d, n], temp_F[n][d], this.temp_B[n][d]);
						for(int q = 0; q<Q; q++) {
							// Message to 'nodeFunctionValues_rep0' from Product factor
							nodeFunctionValues_rep0_B[q][n][d] = GaussianProductVmpOp.BAverageLogarithm(this.temp_B[n][d][q], this.weights_marginal_F[d, q]);
						}
					}
					for(int q = 0; q<Q; q++) {
						// Message to 'nodeFunctionValues_use' from Replicate factor
						nodeFunctionValues_use_B[q][n] = ReplicateOp.DefAverageLogarithm<Gaussian>(nodeFunctionValues_rep0_B[q][n], nodeFunctionValues_use_B[q][n]);
					}
				}
				for(int q = 0; q<Q; q++) {
					// Message to 'nodeFunctions_use_uses' from ArrayFromVector factor
					nodeFunctions_use_uses_B[0][q] = ArrayFromVectorOp.VectorAverageLogarithm(nodeFunctionValues_use_B[q], nodeFunctions_use_uses_B[0][q]);
				}
				// Message to 'nodeFunctions_use' from Replicate factor
				nodeFunctions_use_B = ReplicateOp.DefAverageLogarithm<DistributionRefArray<VectorGaussian,Vector>>(nodeFunctions_use_uses_B, nodeFunctions_use_B);
				for(int q = 0; q<Q; q++) {
					// Message to 'ev_selector_cases_0_rep4_uses' from VectorGaussianScaled factor
					nodeFunctions_B_q__SampleVariance[q] = VectorGaussianScaledPrecisionOp.SampleVariance(this.nodeFunctions_marginal_F[q], nodeFunctions_B_q__SampleVariance[q]);
					// Message to 'ev_selector_cases_0_rep4_uses' from VectorGaussianScaled factor
					nodeFunctions_B_q__SampleMean[q] = VectorGaussianScaledPrecisionOp.SampleMean(this.nodeFunctions_marginal_F[q], nodeFunctions_B_q__SampleVariance[q], nodeFunctions_B_q__SampleMean[q]);
					// Message to 'ev_selector_cases_0_rep4_uses' from VectorGaussianScaled factor
					nodeFunctions_B_q__SampleMean_ESamplePrecisionSample[q] = VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(nodeFunctions_B_q__SampleMean[q], nodeFunctions_B_q__SampleVariance[q], this.k_node_inverse);
					// Message to 'nodeSignalPrecisions_use' from VectorGaussianScaled factor
					nodeSignalPrecisions_use_B[q] = VectorGaussianScaledPrecisionOp.ScalingAverageLogarithm(this.k_node_inverse, nodeFunctions_B_q__SampleMean_ESamplePrecisionSample[q]);
					// Message to 'nodeSignalPrecisions_marginal' from Variable factor
					this.nodeSignalPrecisions_marginal_F[q] = VariableVmpOp.MarginalAverageLogarithm<Gamma>(nodeSignalPrecisions_use_B[q], this.NodeSignalPrecisionsPrior[q], this.nodeSignalPrecisions_marginal_F[q]);
					// Message to 'nodeFunctions' from VectorGaussianScaled factor
					nodeFunctions_F[q] = VectorGaussianScaledPrecisionOp.SampleAverageLogarithm(this.nodeSignalPrecisions_marginal_F[q], this.k_node_inverse, nodeFunctions_F[q]);
					// Message to 'nodeFunctions_marginal' from Variable factor
					this.nodeFunctions_marginal_F[q] = VariableVmpOp.MarginalAverageLogarithm<VectorGaussian>(nodeFunctions_use_B[q], nodeFunctions_F[q], this.nodeFunctions_marginal_F[q]);
					// Message to 'nodeFunctions_use' from Variable factor
					this.nodeFunctions_use_F[q] = Factor.Copy<VectorGaussian>(this.nodeFunctions_marginal_F[q]);
				}
				this.OnProgressChanged(new ProgressChangedEventArgs(iteration));
			}
			// Create array for replicates of 'ev_selector_cases_0_rep1_rep0_uses_B'
			DistributionStructArray<Bernoulli,bool>[][] ev_selector_cases_0_rep1_rep0_uses_B = new DistributionStructArray<Bernoulli,bool>[this.q][];
			for(int q = 0; q<Q; q++) {
				// Create array for 'ev_selector_cases_0_rep1_rep0_uses' Backwards messages.
				ev_selector_cases_0_rep1_rep0_uses_B[q] = new DistributionStructArray<Bernoulli,bool>[2];
				for(int _ind = 0; _ind<2; _ind++) {
					// Create array for 'ev_selector_cases_0_rep1_rep0_uses' Backwards messages.
					ev_selector_cases_0_rep1_rep0_uses_B[q][_ind] = new DistributionStructArray<Bernoulli,bool>(this.d);
					for(int d = 0; d<D; d++) {
						ev_selector_cases_0_rep1_rep0_uses_B[q][_ind][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
					}
				}
				for(int d = 0; d<D; d++) {
					// Message to 'ev_selector_cases_0_rep1_rep0_uses' from Gaussian factor
					ev_selector_cases_0_rep1_rep0_uses_B[q][0][d] = Bernoulli.FromLogOdds(GaussianOp.AverageLogFactor(this.weights_marginal_F[d, q], 0, 1));
					// Message to 'ev_selector_cases_0_rep1_rep0_uses' from Variable factor
					ev_selector_cases_0_rep1_rep0_uses_B[q][1][d] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gaussian>(this.weights_marginal_F[d, q], _hoist0));
				}
			}
			// Create array for replicates of 'ev_selector_cases_0_rep1_rep0_B'
			DistributionStructArray<Bernoulli,bool>[] ev_selector_cases_0_rep1_rep0_B = new DistributionStructArray<Bernoulli,bool>[this.q];
			for(int q = 0; q<Q; q++) {
				// Create array for 'ev_selector_cases_0_rep1_rep0' Backwards messages.
				ev_selector_cases_0_rep1_rep0_B[q] = new DistributionStructArray<Bernoulli,bool>(this.d);
				for(int d = 0; d<D; d++) {
					ev_selector_cases_0_rep1_rep0_B[q][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				}
				// Message to 'ev_selector_cases_0_rep1_rep0' from Replicate factor
				ev_selector_cases_0_rep1_rep0_B[q] = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli,bool>>(ev_selector_cases_0_rep1_rep0_uses_B[q], ev_selector_cases_0_rep1_rep0_B[q]);
			}
			DistributionStructArray<Bernoulli,bool> ev_selector_cases_0_rep1_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'ev_selector_cases_0_rep1' Backwards messages.
			ev_selector_cases_0_rep1_B = new DistributionStructArray<Bernoulli,bool>(this.q);
			for(int q = 0; q<Q; q++) {
				ev_selector_cases_0_rep1_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				// Message to 'ev_selector_cases_0_rep1' from Replicate factor
				ev_selector_cases_0_rep1_B[q] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep1_rep0_B[q], ev_selector_cases_0_rep1_B[q]);
			}
			Bernoulli[] ev_selector_cases_0_uses_B = default(Bernoulli[]);
			// Create array for 'ev_selector_cases_0_uses' Backwards messages.
			ev_selector_cases_0_uses_B = new Bernoulli[41];
			for(int _ind = 0; _ind<41; _ind++) {
				ev_selector_cases_0_uses_B[_ind] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			}
			// Message to 'ev_selector_cases_0_uses' from Replicate factor
			ev_selector_cases_0_uses_B[3] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep1_B, ev_selector_cases_0_uses_B[3]);
			DistributionStructArray<Bernoulli,bool>[] ev_selector_cases_0_rep3_uses_B = default(DistributionStructArray<Bernoulli,bool>[]);
			// Create array for 'ev_selector_cases_0_rep3_uses' Backwards messages.
			ev_selector_cases_0_rep3_uses_B = new DistributionStructArray<Bernoulli,bool>[2];
			for(int _ind = 0; _ind<2; _ind++) {
				// Create array for 'ev_selector_cases_0_rep3_uses' Backwards messages.
				ev_selector_cases_0_rep3_uses_B[_ind] = new DistributionStructArray<Bernoulli,bool>(this.q);
				for(int q = 0; q<Q; q++) {
					ev_selector_cases_0_rep3_uses_B[_ind][q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				}
			}
			for(int q = 0; q<Q; q++) {
				// Message to 'ev_selector_cases_0_rep3_uses' from Random factor
				ev_selector_cases_0_rep3_uses_B[0][q] = Bernoulli.FromLogOdds(UnaryOp<double>.AverageLogFactor<Gamma>(this.nodeSignalPrecisions_marginal_F[q], this.NodeSignalPrecisionsPrior[q]));
				// Message to 'ev_selector_cases_0_rep3_uses' from Variable factor
				ev_selector_cases_0_rep3_uses_B[1][q] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gamma>(this.nodeSignalPrecisions_marginal_F[q], this.NodeSignalPrecisionsPrior[q]));
			}
			DistributionStructArray<Bernoulli,bool> ev_selector_cases_0_rep3_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'ev_selector_cases_0_rep3' Backwards messages.
			ev_selector_cases_0_rep3_B = new DistributionStructArray<Bernoulli,bool>(this.q);
			for(int q = 0; q<Q; q++) {
				ev_selector_cases_0_rep3_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			}
			// Message to 'ev_selector_cases_0_rep3' from Replicate factor
			ev_selector_cases_0_rep3_B = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli,bool>>(ev_selector_cases_0_rep3_uses_B, ev_selector_cases_0_rep3_B);
			// Message to 'ev_selector_cases_0_uses' from Replicate factor
			ev_selector_cases_0_uses_B[10] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep3_B, ev_selector_cases_0_uses_B[10]);
			double _hoist1 = default(double);
			_hoist1 = VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(this.k_node_inverse);
			DistributionStructArray<Bernoulli,bool>[] ev_selector_cases_0_rep4_uses_B = default(DistributionStructArray<Bernoulli,bool>[]);
			// Create array for 'ev_selector_cases_0_rep4_uses' Backwards messages.
			ev_selector_cases_0_rep4_uses_B = new DistributionStructArray<Bernoulli,bool>[2];
			for(int _ind = 0; _ind<2; _ind++) {
				// Create array for 'ev_selector_cases_0_rep4_uses' Backwards messages.
				ev_selector_cases_0_rep4_uses_B[_ind] = new DistributionStructArray<Bernoulli,bool>(this.q);
				for(int q = 0; q<Q; q++) {
					ev_selector_cases_0_rep4_uses_B[_ind][q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				}
			}
			for(int q = 0; q<Q; q++) {
				// Message to 'ev_selector_cases_0_rep4_uses' from VectorGaussianScaled factor
				ev_selector_cases_0_rep4_uses_B[0][q] = Bernoulli.FromLogOdds(VectorGaussianScaledPrecisionOp.AverageLogFactor(nodeFunctions_B_q__SampleMean[q], this.nodeSignalPrecisions_marginal_F[q], nodeFunctions_B_q__SampleMean_ESamplePrecisionSample[q], _hoist1));
				// Message to 'ev_selector_cases_0_rep4_uses' from Variable factor
				ev_selector_cases_0_rep4_uses_B[1][q] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<VectorGaussian>(this.nodeFunctions_marginal_F[q], nodeFunctions_F[q]));
			}

            this.nodeKernelOptimiser.Optimise((prec, gradK, gradientVector) =>
                KernelOptimiser.mlfHelperNode(prec, gradK, gradientVector, nodeFunctions_B_q__SampleMean,
                nodeFunctions_B_q__SampleVariance, this.nodeSignalPrecisions_marginal_F), ref this.k_node_inverse);

			DistributionStructArray<Bernoulli,bool> ev_selector_cases_0_rep4_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'ev_selector_cases_0_rep4' Backwards messages.
			ev_selector_cases_0_rep4_B = new DistributionStructArray<Bernoulli,bool>(this.q);
			for(int q = 0; q<Q; q++) {
				ev_selector_cases_0_rep4_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			}
			// Message to 'ev_selector_cases_0_rep4' from Replicate factor
			ev_selector_cases_0_rep4_B = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli,bool>>(ev_selector_cases_0_rep4_uses_B, ev_selector_cases_0_rep4_B);
			// Message to 'ev_selector_cases_0_uses' from Replicate factor
			ev_selector_cases_0_uses_B[13] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep4_B, ev_selector_cases_0_uses_B[13]);
			// Message to 'ev_selector_cases_0_uses' from Random factor
			ev_selector_cases_0_uses_B[29] = Bernoulli.FromLogOdds(UnaryOp<double>.AverageLogFactor<Gamma>(this.noisePrecision_marginal_F, this.NoisePrecisionPrior));
			// Message to 'ev_selector_cases_0_uses' from Variable factor
			ev_selector_cases_0_uses_B[30] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gamma>(this.noisePrecision_marginal_F, this.NoisePrecisionPrior));
			// Create array for replicates of 'ev_selector_cases_0_rep11_rep0_uses_B'
			DistributionStructArray<Bernoulli,bool>[][] ev_selector_cases_0_rep11_rep0_uses_B = new DistributionStructArray<Bernoulli,bool>[this.n][];
			for(int n = 0; n<N; n++) {
				// Create array for 'ev_selector_cases_0_rep11_rep0_uses' Backwards messages.
				ev_selector_cases_0_rep11_rep0_uses_B[n] = new DistributionStructArray<Bernoulli,bool>[5];
				for(int _ind = 0; _ind<5; _ind++) {
					// Create array for 'ev_selector_cases_0_rep11_rep0_uses' Backwards messages.
					ev_selector_cases_0_rep11_rep0_uses_B[n][_ind] = new DistributionStructArray<Bernoulli,bool>(this.d);
					for(int d = 0; d<D; d++) {
						ev_selector_cases_0_rep11_rep0_uses_B[n][_ind][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
					}
				}
				for(int d = 0; d<D; d++) {
					if (!this.IsMissing[d, n]) {
						// Message to 'ev_selector_cases_0_rep11_rep0_uses' from Gaussian factor
						ev_selector_cases_0_rep11_rep0_uses_B[n][4][d] = Bernoulli.FromLogOdds(GaussianOp.AverageLogFactor(this.ObservedData[d, n], this.noiseLessY_F[d, n], this.noisePrecision_marginal_F));
					}
				}
			}
			// Create array for replicates of 'ev_selector_cases_0_rep11_rep0_B'
			DistributionStructArray<Bernoulli,bool>[] ev_selector_cases_0_rep11_rep0_B = new DistributionStructArray<Bernoulli,bool>[this.n];
			for(int n = 0; n<N; n++) {
				// Create array for 'ev_selector_cases_0_rep11_rep0' Backwards messages.
				ev_selector_cases_0_rep11_rep0_B[n] = new DistributionStructArray<Bernoulli,bool>(this.d);
				for(int d = 0; d<D; d++) {
					ev_selector_cases_0_rep11_rep0_B[n][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				}
				// Message to 'ev_selector_cases_0_rep11_rep0' from Replicate factor
				ev_selector_cases_0_rep11_rep0_B[n] = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli,bool>>(ev_selector_cases_0_rep11_rep0_uses_B[n], ev_selector_cases_0_rep11_rep0_B[n]);
			}
			DistributionStructArray<Bernoulli,bool> ev_selector_cases_0_rep11_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'ev_selector_cases_0_rep11' Backwards messages.
			ev_selector_cases_0_rep11_B = new DistributionStructArray<Bernoulli,bool>(this.n);
			for(int n = 0; n<N; n++) {
				ev_selector_cases_0_rep11_B[n] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				// Message to 'ev_selector_cases_0_rep11' from Replicate factor
				ev_selector_cases_0_rep11_B[n] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep11_rep0_B[n], ev_selector_cases_0_rep11_B[n]);
			}
			// Message to 'ev_selector_cases_0_uses' from Replicate factor
			ev_selector_cases_0_uses_B[36] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep11_B, ev_selector_cases_0_uses_B[36]);
			// Create array for replicates of 'ev_selector_cases_0_rep13_rep0_B'
			DistributionStructArray<Bernoulli,bool>[] ev_selector_cases_0_rep13_rep0_B = new DistributionStructArray<Bernoulli,bool>[this.n];
			for(int n = 0; n<N; n++) {
				// Create array for 'ev_selector_cases_0_rep13_rep0' Backwards messages.
				ev_selector_cases_0_rep13_rep0_B[n] = new DistributionStructArray<Bernoulli,bool>(this.d);
				for(int d = 0; d<D; d++) {
					ev_selector_cases_0_rep13_rep0_B[n][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
					if (this.IsMissing[d, n]) {
						// Message to 'ev_selector_cases_0_rep13_rep0' from Gaussian factor
						ev_selector_cases_0_rep13_rep0_B[n][d] = Bernoulli.FromLogOdds(GaussianOp.AverageLogFactor(this.ObservedData[d, n], 0, 1));
					}
				}
			}
			DistributionStructArray<Bernoulli,bool> ev_selector_cases_0_rep13_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'ev_selector_cases_0_rep13' Backwards messages.
			ev_selector_cases_0_rep13_B = new DistributionStructArray<Bernoulli,bool>(this.n);
			for(int n = 0; n<N; n++) {
				ev_selector_cases_0_rep13_B[n] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				// Message to 'ev_selector_cases_0_rep13' from Replicate factor
				ev_selector_cases_0_rep13_B[n] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep13_rep0_B[n], ev_selector_cases_0_rep13_B[n]);
			}
			// Message to 'ev_selector_cases_0_uses' from Replicate factor
			ev_selector_cases_0_uses_B[40] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep13_B, ev_selector_cases_0_uses_B[40]);
			Bernoulli ev_selector_cases_0_B = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			// Message to 'ev_selector_cases_0' from Replicate factor
			ev_selector_cases_0_B = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_uses_B, ev_selector_cases_0_B);
			DistributionStructArray<Bernoulli,bool> ev_selector_cases_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'ev_selector_cases' Backwards messages.
			ev_selector_cases_B = new DistributionStructArray<Bernoulli,bool>(2);
			for(int _ind0 = 0; _ind0<2; _ind0++) {
				ev_selector_cases_B[_ind0] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			}
			// Message to 'ev_selector_cases' from Copy factor
			ev_selector_cases_B[0] = Factor.Copy<Bernoulli>(ev_selector_cases_0_B);
			Bernoulli ev_selector_B = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
			// Message to 'ev_selector' from Cases factor
			ev_selector_B = CasesOp.BAverageLogarithm(ev_selector_cases_B);
			// Message to 'ev_marginal' from Variable factor
			this.ev_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Bernoulli>(ev_selector_B, vBernoulli0, this.ev_marginal_F);
			// Create array for 'nodeFunctionValuesPredictive' Forwards messages.
			this.nodeFunctionValuesPredictive_F = new DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]>(this.q);
			for(int q = 0; q<Q; q++) {
				// Create array for 'nodeFunctionValuesPredictive' Forwards messages.
				this.nodeFunctionValuesPredictive_F[q] = new DistributionStructArray<Gaussian,double>(this.n);
				for(int _iv1 = 0; _iv1<N; _iv1++) {
					this.nodeFunctionValuesPredictive_F[q][_iv1] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
				}
				// Message to 'nodeFunctionValuesPredictive' from ArrayFromVector factor
				this.nodeFunctionValuesPredictive_F[q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian,double>>(this.nodeFunctions_use_F[q], this.nodeFunctionValuesPredictive_F[q]);
			}
			this.Changed_numberOfIterationsDecreased_Q_N_D_isMissing_observedData_noisePrecisionPrior_K_node_inverse_0_iterationsDone = numberOfIterations;
		}

		/// <summary>
		/// Returns the marginal distribution for 'ev' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Bernoulli EvMarginal()
		{
			return this.ev_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'weights' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public DistributionStructArray2D<Gaussian,double> WeightsMarginal()
		{
			return this.weights_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'nodeSignalPrecisions' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public DistributionStructArray<Gamma,double> NodeSignalPrecisionsMarginal()
		{
			return this.nodeSignalPrecisions_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'nodeFunctionValues' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]> NodeFunctionValuesMarginal()
		{
			return this.nodeFunctionValues_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'noiseLessY' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public DistributionStructArray2D<Gaussian,double> NoiseLessYMarginal()
		{
			return this.noiseLessY_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'noisePrecision' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Gamma NoisePrecisionMarginal()
		{
			return this.noisePrecision_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'nodeFunctionValuesPredictive' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public DistributionRefArray<DistributionStructArray<Gaussian,double>,double[]> NodeFunctionValuesPredictiveMarginal()
		{
			return this.nodeFunctionValuesPredictive_F;
		}

		#endregion

		#region Events
		/// <summary>Event that is fired when the progress of inference changes, typically at the end of one iteration of the inference algorithm.</summary>
		public event EventHandler<ProgressChangedEventArgs> ProgressChanged;
		#endregion

	}

}
