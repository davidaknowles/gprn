using System;
using System.Linq; 
using MicrosoftResearch.Infer;
using MicrosoftResearch.Infer.Distributions;
using MicrosoftResearch.Infer.Maths;
using MicrosoftResearch.Infer.Collections;
using gpnetworkVB;
using MicrosoftResearch.Infer.Factors;

namespace gpnetworkVB
{
    /// <summary>
    /// Class for performing inference in model 'Model' using algorithm 'VariationalMessagePassing'.
    /// </summary>
    /// <remarks>
    /// The easiest way to use this class is to wrap an instance in a CompiledAlgorithm object and use
    /// the methods on CompiledAlgorithm to set parameters and execute inference.
    /// 
    /// If you instead wish to use this class directly, you must perform the following steps:
    /// 1) Create an instance of the class
    /// 2) Set the value of any externally-set fields e.g. data, priors
    /// 3) Call the Execute(numberOfIterations) method
    /// 4) Use the XXXMarginal() methods to retrieve posterior marginals for different variables.
    /// 
    /// Generated by Infer.NET 2.4 beta 2 at 16:40 on 17 August 2011.
    /// </remarks>
    public class VMPModel_nodeNoise : IGeneratedAlgorithm
    {
        #region Fields

        public Converter<double, PositiveDefiniteMatrix> K_node_inverse_func;
        public Converter<double, PositiveDefiniteMatrix> K_weight_inverse_func; 
        public double nodeLogLengthScale;
        public double weightsLogLengthScale;

        public Gaussian priorOnNodeLogLengthScale;
        public Gaussian priorOnWeightLogLengthScale; 

        public int firstIterationToOptimiseNodeLengthScale = 0;
        public int firstIterationToOptimiseWeightLengthScale = 0;

        /// <summary>Field backing the NumberOfIterationsDone property</summary>
        private int numberOfIterationsDone;
        /// <summary>Field backing the Q property</summary>
        private int q;
        /// <summary>Field backing the nodeFunctionsInitVar property</summary>
        private IDistribution<Vector[]> NodeFunctionsInitVar;
        /// <summary>Field backing the K_node_inverse property</summary>
        private PositiveDefiniteMatrix k_node_inverse;
        /// <summary>Field backing the N property</summary>
        private int n;
        /// <summary>Field backing the D property</summary>
        private int d;
        /// <summary>Field backing the K_weights_inverse property</summary>
        private PositiveDefiniteMatrix k_weights_inverse;
        /// <summary>Field backing the observedData property</summary>
        private double[,] ObservedData;
        /// <summary>The number of iterations last computed by Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0. Set this to zero to force re-execution of Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0</summary>
        public int Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_N. Set this to zero to force re-execution of Changed_N</summary>
        public int Changed_N_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_N_D. Set this to zero to force re-execution of Changed_N_D</summary>
        public int Changed_N_D_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_N_D_Q. Set this to zero to force re-execution of Changed_N_D_Q</summary>
        public int Changed_N_D_Q_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4. Set this to zero to force re-execution of Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4</summary>
        public int Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone;
        /// <summary>True if Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4 has performed initialisation. Set this to false to force re-execution of Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4</summary>
        public bool Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_isInitialised;
        /// <summary>The number of iterations last computed by Constant. Set this to zero to force re-execution of Constant</summary>
        public int Constant_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6. Set this to zero to force re-execution of Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6</summary>
        public int Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_iterationsDone;
        /// <summary>True if Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6 has performed initialisation. Set this to false to force re-execution of Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6</summary>
        public bool Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised;
        /// <summary>The number of iterations last computed by Changed_D_Q. Set this to zero to force re-execution of Changed_D_Q</summary>
        public int Changed_D_Q_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8. Set this to zero to force re-execution of Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8</summary>
        public int Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_iterationsDone;
        /// <summary>True if Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8 has performed initialisation. Set this to false to force re-execution of Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8</summary>
        public bool Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised;
        /// <summary>Message to marginal of 'nodeFunctions'</summary>
        public DistributionRefArray<VectorGaussian, Vector> nodeFunctions_marginal_B;
        /// <summary>Message to use of 'nodeFunctions'</summary>
        public DistributionRefArray<VectorGaussian, Vector> nodeFunctions_use_F;
        /// <summary>Message from use of 'weightFunctions'</summary>
        public DistributionRefArray2D<VectorGaussian, Vector> weightFunctions_use_B;
        public DistributionStructArray<Gaussian, double>[][] temp_B;
        /// <summary>Message to marginal of 'ev'</summary>
        public Bernoulli ev_marginal_B;
        /// <summary>Message to marginal of 'noisePrecision'</summary>
        public Gamma noisePrecision_marginal_B;
        /// <summary>Message to marginal of 'nodeSignalPrecisions'</summary>
        public DistributionStructArray<Gamma, double> nodeSignalPrecisions_marginal_B;
        #endregion

        #region Properties
        /// <summary>The number of iterations done from the initial state</summary>
        public int NumberOfIterationsDone
        {
            get
            {
                return this.numberOfIterationsDone;
            }
        }

        /// <summary>The externally-specified value of 'Q'</summary>
        public int Q
        {
            get
            {
                return this.q;
            }
            set
            {
                if (this.q != value)
                {
                    this.q = value;
                    this.numberOfIterationsDone = 0;
                    this.Changed_D_Q_iterationsDone = 0;
                    this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_iterationsDone = 0;
                    this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised = false;
                    this.Changed_N_D_Q_iterationsDone = 0;
                    this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone = 0;
                    this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
                }
            }
        }

        /// <summary>The externally-specified value of 'nodeFunctionsInitVar'</summary>
        public IDistribution<Vector[]> nodeFunctionsInitVar
        {
            get
            {
                return this.NodeFunctionsInitVar;
            }
            set
            {
                this.NodeFunctionsInitVar = value;
                this.numberOfIterationsDone = 0;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_iterationsDone = 0;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
            }
        }

        /// <summary>The externally-specified value of 'K_node_inverse'</summary>
        public PositiveDefiniteMatrix K_node_inverse
        {
            get
            {
                return this.k_node_inverse;
            }
            set
            {
                this.k_node_inverse = value;
                this.numberOfIterationsDone = 0;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised = false;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
            }
        }

        /// <summary>The externally-specified value of 'N'</summary>
        public int N
        {
            get
            {
                return this.n;
            }
            set
            {
                if (this.n != value)
                {
                    this.n = value;
                    this.numberOfIterationsDone = 0;
                    this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised = false;
                    this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised = false;
                    this.Changed_N_iterationsDone = 0;
                    this.Changed_N_D_iterationsDone = 0;
                    this.Changed_N_D_Q_iterationsDone = 0;
                    this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone = 0;
                    this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
                }
            }
        }

        /// <summary>The externally-specified value of 'D'</summary>
        public int D
        {
            get
            {
                return this.d;
            }
            set
            {
                if (this.d != value)
                {
                    this.d = value;
                    this.numberOfIterationsDone = 0;
                    this.Changed_D_Q_iterationsDone = 0;
                    this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_iterationsDone = 0;
                    this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised = false;
                    this.Changed_N_D_iterationsDone = 0;
                    this.Changed_N_D_Q_iterationsDone = 0;
                    this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone = 0;
                    this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
                }
            }
        }

        /// <summary>The externally-specified value of 'K_weights_inverse'</summary>
        public PositiveDefiniteMatrix K_weights_inverse
        {
            get
            {
                return this.k_weights_inverse;
            }
            set
            {
                this.k_weights_inverse = value;
                this.numberOfIterationsDone = 0;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised = false;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
            }
        }

        /// <summary>The externally-specified value of 'observedData'</summary>
        public double[,] observedData
        {
            get
            {
                return this.ObservedData;
            }
            set
            {
                if ((value != null) && (((value.GetLength(0)) != this.d) || ((value.GetLength(1)) != this.n)))
                {
                    throw new ArgumentException(((("Provided array of size " + (((("(" + (value.GetLength(0))) + ",") + (value.GetLength(1))) + ")")) + " when size ") + (((("(" + this.d) + ",") + this.n) + ")")) + " was expected");
                }
                this.ObservedData = value;
                this.numberOfIterationsDone = 0;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised = false;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
            }
        }

        #endregion

        #region Methods
        /// <summary>Get the observed value of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        public object GetObservedValue(string variableName)
        {
            if (variableName == "Q")
            {
                return this.Q;
            }
            if (variableName == "nodeFunctionsInitVar")
            {
                return this.nodeFunctionsInitVar;
            }
            if (variableName == "K_node_inverse")
            {
                return this.K_node_inverse;
            }
            if (variableName == "N")
            {
                return this.N;
            }
            if (variableName == "D")
            {
                return this.D;
            }
            if (variableName == "K_weights_inverse")
            {
                return this.K_weights_inverse;
            }
            if (variableName == "observedData")
            {
                return this.observedData;
            }
            throw new ArgumentException("Not an observed variable name: " + variableName);
        }

        /// <summary>Set the observed value of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        /// <param name="value">Observed value</param>
        public void SetObservedValue(string variableName, object value)
        {
            if (variableName == "Q")
            {
                this.Q = (int)value;
                return;
            }
            if (variableName == "nodeFunctionsInitVar")
            {
                this.nodeFunctionsInitVar = (IDistribution<Vector[]>)value;
                return;
            }
            if (variableName == "K_node_inverse")
            {
                this.K_node_inverse = (PositiveDefiniteMatrix)value;
                return;
            }
            if (variableName == "N")
            {
                this.N = (int)value;
                return;
            }
            if (variableName == "D")
            {
                this.D = (int)value;
                return;
            }
            if (variableName == "K_weights_inverse")
            {
                this.K_weights_inverse = (PositiveDefiniteMatrix)value;
                return;
            }
            if (variableName == "observedData")
            {
                this.observedData = (double[,])value;
                return;
            }
            throw new ArgumentException("Not an observed variable name: " + variableName);
        }

        /// <summary>The marginal distribution of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        public object Marginal(string variableName)
        {
            if (variableName == "ev")
            {
                return this.EvMarginal();
            }
            if (variableName == "noisePrecision")
            {
                return this.NoisePrecisionMarginal();
            }
            if (variableName == "nodeSignalPrecisions")
            {
                return this.NodeSignalPrecisionsMarginal();
            }
            throw new ArgumentException("This class was not built to infer " + variableName);
        }

        public T Marginal<T>(string variableName)
        {
            return Distribution.ChangeType<T>(this.Marginal(variableName));
        }

        /// <summary>The query-specific marginal distribution of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        /// <param name="query">QueryType name. For example, GibbsSampling answers 'Marginal', 'Samples', and 'Conditionals' queries</param>
        public object Marginal(string variableName, string query)
        {
            if (query == "Marginal")
            {
                return this.Marginal(variableName);
            }
            throw new ArgumentException(((("This class was not built to infer \'" + variableName) + "\' with query \'") + query) + "\'");
        }

        public T Marginal<T>(string variableName, string query)
        {
            return Distribution.ChangeType<T>(this.Marginal(variableName, query));
        }

        /// <summary>The output message of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        public object GetOutputMessage(string variableName)
        {
            throw new ArgumentException("This class was not built to compute an output message for " + variableName);
        }

        /// <summary>Update all marginals, by iterating message passing the given number of times</summary>
        /// <param name="numberOfIterations">The number of times to iterate each loop</param>
        /// <param name="initialise">If true, messages that initialise loops are reset when observed values change</param>
        private void Execute(int numberOfIterations, bool initialise)
        {
            if (numberOfIterations < this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone)
            {
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised = false;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
            }
            this.Constant();
            this.Changed_D_Q();
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8(initialise);
            this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6(initialise);
            this.Changed_N();
            this.Changed_N_D();
            this.Changed_N_D_Q();
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4(initialise);
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0(numberOfIterations);
            this.numberOfIterationsDone = numberOfIterations;
        }

        public void Execute(int numberOfIterations)
        {
            this.Execute(numberOfIterations, true);
        }

        public void Update(int additionalIterations)
        {
            this.Execute(this.numberOfIterationsDone + additionalIterations, false);
        }

        private void OnProgressChanged(ProgressChangedEventArgs e)
        {
            // Make a temporary copy of the event to avoid a race condition
            // if the last subscriber unsubscribes immediately after the null check and before the event is raised.
            EventHandler<ProgressChangedEventArgs> handler = this.ProgressChanged;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        /// <summary>Reset all messages to their initial values.  Sets NumberOfIterationsDone to 0.</summary>
        public void Reset()
        {
            this.Execute(0);
        }

        /// <summary>Computations that do not depend on observed values</summary>
        public void Constant()
        {
            if (this.Constant_iterationsDone == 1)
            {
                return;
            }
            this.Constant_iterationsDone = 1;
            this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
            this.Changed_D_Q_iterationsDone = 0;
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of D and Q</summary>
        public void Changed_D_Q()
        {
            if (this.Changed_D_Q_iterationsDone == 1)
            {
                return;
            }
            // Create array for 'weightFunctions_use' Backwards messages.
            this.weightFunctions_use_B = new DistributionRefArray2D<VectorGaussian, Vector>(this.d, this.q);
            this.Changed_D_Q_iterationsDone = 1;
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of D and Q and must reset on changes to numberOfIterationsDecreased and N and observedData and K_node_inverse and nodeFunctionsInitVar and K_weights_inverse</summary>
        /// <param name="initialise">If true, reset messages that initialise loops</param>
        public void Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8(bool initialise)
        {
            if ((this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_iterationsDone == 1) && ((!initialise) || this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised))
            {
                return;
            }
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    this.weightFunctions_use_B[d, q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(this.n));
                }
            }
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_iterationsDone = 1;
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_K_node_inverse_nodeFunctionsInitVar_K_we8_isInitialised = true;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of nodeFunctionsInitVar and must reset on changes to numberOfIterationsDecreased and Q and N and D and observedData and K_node_inverse and K_weights_inverse</summary>
        /// <param name="initialise">If true, reset messages that initialise loops</param>
        public void Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6(bool initialise)
        {
            if ((this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_iterationsDone == 1) && ((!initialise) || this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised))
            {
                return;
            }
            // Create array for 'nodeFunctions_marginal' Backwards messages.
            this.nodeFunctions_marginal_B = ArrayHelper.MakeCopy<DistributionRefArray<VectorGaussian, Vector>>((DistributionRefArray<VectorGaussian, Vector>)this.NodeFunctionsInitVar);
            // Create array for 'nodeFunctions_use' Forwards messages.
            this.nodeFunctions_use_F = ArrayHelper.MakeCopy<DistributionRefArray<VectorGaussian, Vector>>((DistributionRefArray<VectorGaussian, Vector>)this.NodeFunctionsInitVar);
            this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_iterationsDone = 1;
            this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_K_we6_isInitialised = true;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of N</summary>
        public void Changed_N()
        {
            if (this.Changed_N_iterationsDone == 1)
            {
                return;
            }
            // Create array for replicates of 'temp_B'
            this.temp_B = new DistributionStructArray<Gaussian, double>[this.n][];
            this.Changed_N_iterationsDone = 1;
            this.Changed_N_D_iterationsDone = 0;
            this.Changed_N_D_Q_iterationsDone = 0;
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of N and D</summary>
        public void Changed_N_D()
        {
            if (this.Changed_N_D_iterationsDone == 1)
            {
                return;
            }
            for (int n = 0; n < N; n++)
            {
                // Create array for replicates of 'temp_B'
                this.temp_B[n] = new DistributionStructArray<Gaussian, double>[this.d];
            }
            this.Changed_N_D_iterationsDone = 1;
            this.Changed_N_D_Q_iterationsDone = 0;
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of N and D and Q</summary>
        public void Changed_N_D_Q()
        {
            if (this.Changed_N_D_Q_iterationsDone == 1)
            {
                return;
            }
            for (int n = 0; n < N; n++)
            {
                for (int d = 0; d < D; d++)
                {
                    // Create array for 'temp' Backwards messages.
                    this.temp_B[n][d] = new DistributionStructArray<Gaussian, double>(this.q);
                }
            }
            this.Changed_N_D_Q_iterationsDone = 1;
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of N and D and Q and must reset on changes to numberOfIterationsDecreased and observedData and K_node_inverse and nodeFunctionsInitVar and K_weights_inverse</summary>
        /// <param name="initialise">If true, reset messages that initialise loops</param>
        public void Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4(bool initialise)
        {
            if ((this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone == 1) && ((!initialise) || this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_isInitialised))
            {
                return;
            }
            for (int n = 0; n < N; n++)
            {
                for (int d = 0; d < D; d++)
                {
                    for (int q = 0; q < Q; q++)
                    {
                        this.temp_B[n][d][q] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_iterationsDone = 1;
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_K_node_inverse_nodeFunctionsInitVar_K_we4_isInitialised = true;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = 0;
        }

        public void OptimiseNodeLogLengthscale(Vector[] functions_SampleMean,
            double[] functions_ESamplePrecisionSample,
            PositiveDefiniteMatrix[] functions_SampleVariance,
            double L_K_node)
        {
            double eps = 0.3;
            double[] nodeLL = new double[] { nodeLogLengthScale - eps, nodeLogLengthScale + eps };
            L_K_node += this.priorOnNodeLogLengthScale.GetLogProb(nodeLogLengthScale);
            var K_node_inverse_prop = nodeLL.Select(i => K_node_inverse_func(i)).ToArray();
            var K_node_inverse_logDet_prop = K_node_inverse_prop.Select(i => VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(i)).ToArray();
            var L = nodeLL.Select(i => priorOnNodeLogLengthScale.GetLogProb(i)).ToArray();
            for (int q = 0; q < Q; q++)
            {
                L[0] += VectorGaussianScaledPrecisionOp.AverageLogFactor(functions_SampleMean[q], this.nodeSignalPrecisions_marginal_B[q],
                    VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(functions_SampleMean[q], functions_SampleVariance[q], K_node_inverse_prop[0]),
                    K_node_inverse_logDet_prop[0]);
                L[1] += VectorGaussianScaledPrecisionOp.AverageLogFactor(functions_SampleMean[q], this.nodeSignalPrecisions_marginal_B[q],
                    VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(functions_SampleMean[q], functions_SampleVariance[q], K_node_inverse_prop[1]),
                    K_node_inverse_logDet_prop[1]);
            }
            // fit quadratic (take current x=0)
            double c = L_K_node;
            double b = (L[1] - L[0]) / (2.0 * eps);
            double m = (b * eps + L[0] - L_K_node) / (eps * eps);
            double newL = 0;
            if (m < 0) // good! 
            {
                nodeLogLengthScale += -b / (2.0 * m); // optimum of quadratic

                // check whether this actual improved things...
                newL = priorOnNodeLogLengthScale.GetLogProb(nodeLogLengthScale);
                var newKinv = K_node_inverse_func(nodeLogLengthScale);
                double newLogDet = VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(newKinv);
                for (int q = 0; q < Q; q++)
                {
                    newL += VectorGaussianScaledPrecisionOp.AverageLogFactor(functions_SampleMean[q], this.nodeSignalPrecisions_marginal_B[q], VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(functions_SampleMean[q], functions_SampleVariance[q], newKinv), newLogDet);
                }
            }
            else // non convex: just take best out of evaluated points
            {
                Console.WriteLine("Warning: nonconvex in node log length scale, m=" + m);
                var temp = new double[] { L[0], L_K_node, L[1] };
                int i = MMath.IndexOfMaximum(temp);
                newL = temp.Max();
                nodeLogLengthScale = new double[] { nodeLogLengthScale - eps, nodeLogLengthScale, nodeLogLengthScale + eps }[i];
            }
            //Console.WriteLine("Node ll {0}, likelihood went from {1} to {2}", nodeLogLengthScale, L_K_node, newL);
        }

        public void OptimiseWeightLogLengthscale(Vector[][] functions_SampleMean,
            double[][] functions_ESamplePrecisionSample,
            PositiveDefiniteMatrix[][] functions_SampleVariance,
            double L_K_weight)
        {
            double eps = 0.3;
            L_K_weight += priorOnWeightLogLengthScale.GetLogProb(weightsLogLengthScale);
            double[] weightLL = new double[2] { weightsLogLengthScale - eps, weightsLogLengthScale + eps };
            var K_weight_inverse_prop = weightLL.Select(i => K_weight_inverse_func(i)).ToArray();
            var K_inverse_logDet_prop = K_weight_inverse_prop.Select(i => VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(i)).ToArray();
            var L = weightLL.Select(i => priorOnWeightLogLengthScale.GetLogProb(i)).ToArray();
            for (int q = 0; q < Q; q++)
            {
                for (int d = 0; d < D; d++)
                {
                    L[0] += VectorGaussianScaledPrecisionOp.AverageLogFactor(functions_SampleMean[q][d], 1,
                        VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(functions_SampleMean[q][d], functions_SampleVariance[q][d], K_weight_inverse_prop[0]),
                        K_inverse_logDet_prop[0]);
                    L[1] += VectorGaussianScaledPrecisionOp.AverageLogFactor(functions_SampleMean[q][d], 1,
                        VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(functions_SampleMean[q][d], functions_SampleVariance[q][d], K_weight_inverse_prop[1]),
                        K_inverse_logDet_prop[1]);
                }
            }
            // fit quadratic (take current x=0)
            double c = L_K_weight;
            double b = (L[1] - L[0]) / (2.0 * eps);
            double m = (b * eps + L[0] - L_K_weight) / (eps * eps);
            double newL = 0;
            if (m < 0) // good! 
            {
                weightsLogLengthScale += -b / (2.0 * m); // optimum of quadratic

                newL = priorOnWeightLogLengthScale.GetLogProb(weightsLogLengthScale);
                var newKprec = K_weight_inverse_func(weightsLogLengthScale);
                var newKlogdet = VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(newKprec);
                for (int q = 0; q < Q; q++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        newL += VectorGaussianScaledPrecisionOp.AverageLogFactor(functions_SampleMean[q][d], 1,
                            VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(functions_SampleMean[q][d], functions_SampleVariance[q][d], newKprec),
                            newKlogdet);
                    }
                }
            }
            else // non convex: just take best out of evaluated points
            {
                Console.WriteLine("Warning: nonconvex in weight log length scale, m=" + m);
                var temp = new double[] { L[0], L_K_weight, L[1] };
                int i = MMath.IndexOfMaximum(temp);
                newL = temp.Max();
                weightsLogLengthScale = new double[] { weightsLogLengthScale - eps, weightsLogLengthScale, weightsLogLengthScale + eps }[i];
            }
            //Console.WriteLine("Weight ll {0}, likelihood went from {1} to {2}", weightsLogLengthScale, L_K_weight, newL);
        }


        /// <summary>Computations that depend on the observed value of numberOfIterationsDecreased and Q and N and D and observedData and K_node_inverse and nodeFunctionsInitVar and K_weights_inverse</summary>
        /// <param name="numberOfIterations">The number of times to iterate each loop</param>
        public void Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0(int numberOfIterations)
        {
            if (this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone == numberOfIterations)
            {
                return;
            }
            // The constant 'vBernoulli0'
            Bernoulli vBernoulli0 = Bernoulli.FromLogOdds(0);
            this.ev_marginal_B = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
            // Create array for replicates of 'sum_B'
            Gaussian[][] sum_B = new Gaussian[this.n][];
            for (int n = 0; n < N; n++)
            {
                // Create array for replicates of 'sum_B'
                sum_B[n] = new Gaussian[this.d];
                for (int d = 0; d < D; d++)
                {
                    sum_B[n][d] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
            }
            this.noisePrecision_marginal_B = ArrayHelper.MakeUniform<Gamma>(Gamma.Uniform());
            // Create array for replicates of 'temp_F'
            DistributionStructArray<Gaussian, double>[][] temp_F = new DistributionStructArray<Gaussian, double>[this.n][];
            for (int n = 0; n < N; n++)
            {
                // Create array for replicates of 'temp_F'
                temp_F[n] = new DistributionStructArray<Gaussian, double>[this.d];
                for (int d = 0; d < D; d++)
                {
                    // Create array for 'temp' Forwards messages.
                    temp_F[n][d] = new DistributionStructArray<Gaussian, double>(this.q);
                    for (int q = 0; q < Q; q++)
                    {
                        temp_F[n][d][q] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            // Create array for replicates of 'nodeFunctionValues_rep0_B'
            DistributionStructArray<Gaussian, double>[][] nodeFunctionValues_rep0_B = new DistributionStructArray<Gaussian, double>[this.q][];
            for (int q = 0; q < Q; q++)
            {
                // Create array for replicates of 'nodeFunctionValues_rep0_B'
                nodeFunctionValues_rep0_B[q] = new DistributionStructArray<Gaussian, double>[this.n];
                for (int n = 0; n < N; n++)
                {
                    // Create array for 'nodeFunctionValues_rep0' Backwards messages.
                    nodeFunctionValues_rep0_B[q][n] = new DistributionStructArray<Gaussian, double>(this.d);
                    for (int d = 0; d < D; d++)
                    {
                        nodeFunctionValues_rep0_B[q][n][d] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]> weightFunctionValues_F = default(DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]>);
            // Create array for 'weightFunctionValues' Forwards messages.
            weightFunctionValues_F = new DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    // Create array for 'weightFunctionValues' Forwards messages.
                    weightFunctionValues_F[d, q] = new DistributionStructArray<Gaussian, double>(this.n);
                    for (int _ind0 = 0; _ind0 < N; _ind0++)
                    {
                        weightFunctionValues_F[d, q][_ind0] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]> nodeFunctionValues_B = default(DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]>);
            // Create array for 'nodeFunctionValues' Backwards messages.
            nodeFunctionValues_B = new DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]>(this.q);
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'nodeFunctionValues' Backwards messages.
                nodeFunctionValues_B[q] = new DistributionStructArray<Gaussian, double>(this.n);
                for (int _ind0 = 0; _ind0 < N; _ind0++)
                {
                    nodeFunctionValues_B[q][_ind0] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
            }
            // Message from use of 'nodeFunctions'
            DistributionRefArray<VectorGaussian, Vector> nodeFunctions_use_B = default(DistributionRefArray<VectorGaussian, Vector>);
            // Create array for 'nodeFunctions_use' Backwards messages.
            nodeFunctions_use_B = new DistributionRefArray<VectorGaussian, Vector>(this.q);
            for (int q = 0; q < Q; q++)
            {
                nodeFunctions_use_B[q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(this.n));
            }
            // Buffer for VectorGaussianScaledPrecisionOp.SampleMean
            // Create array for replicates of 'nodeFunctions_B_q__SampleVariance'
            PositiveDefiniteMatrix[] nodeFunctions_B_q__SampleVariance = new PositiveDefiniteMatrix[this.q];
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep1_uses' from VectorGaussianScaled factor
                nodeFunctions_B_q__SampleVariance[q] = VectorGaussianScaledPrecisionOp.SampleVarianceInit(this.nodeFunctions_marginal_B[q]);
            }
            // Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
            // Create array for replicates of 'nodeFunctions_B_q__SampleMean'
            Vector[] nodeFunctions_B_q__SampleMean = new Vector[this.q];
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep1_uses' from VectorGaussianScaled factor
                nodeFunctions_B_q__SampleMean[q] = VectorGaussianScaledPrecisionOp.SampleMeanInit(this.nodeFunctions_marginal_B[q]);
            }
            // Message from use of 'nodeSignalPrecisions'
            DistributionStructArray<Gamma, double> nodeSignalPrecisions_use_B = default(DistributionStructArray<Gamma, double>);
            // Create array for 'nodeSignalPrecisions_use' Backwards messages.
            nodeSignalPrecisions_use_B = new DistributionStructArray<Gamma, double>(this.q);
            for (int q = 0; q < Q; q++)
            {
                nodeSignalPrecisions_use_B[q] = ArrayHelper.MakeUniform<Gamma>(Gamma.Uniform());
            }
            Gamma _hoist0 = default(Gamma);
            _hoist0 = GammaFromShapeAndRateOp.YAverageLogarithm(0.1, 0.1);
            // Create array for 'nodeSignalPrecisions_marginal' Backwards messages.
            this.nodeSignalPrecisions_marginal_B = new DistributionStructArray<Gamma, double>(this.q);
            for (int q = 0; q < Q; q++)
            {
                this.nodeSignalPrecisions_marginal_B[q] = ArrayHelper.MakeUniform<Gamma>(Gamma.Uniform());
            }
            DistributionRefArray<VectorGaussian, Vector> nodeFunctions_F = default(DistributionRefArray<VectorGaussian, Vector>);
            // Create array for 'nodeFunctions' Forwards messages.
            nodeFunctions_F = new DistributionRefArray<VectorGaussian, Vector>(this.q);
            for (int q = 0; q < Q; q++)
            {
                nodeFunctions_F[q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(this.n));
            }
            DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]> nodeFunctionValues_F = default(DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]>);
            // Create array for 'nodeFunctionValues' Forwards messages.
            nodeFunctionValues_F = new DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]>(this.q);
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'nodeFunctionValues' Forwards messages.
                nodeFunctionValues_F[q] = new DistributionStructArray<Gaussian, double>(this.n);
                for (int _ind0 = 0; _ind0 < N; _ind0++)
                {
                    nodeFunctionValues_F[q][_ind0] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
            }
            DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]> weightFunctionValues_B = default(DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]>);
            // Create array for 'weightFunctionValues' Backwards messages.
            weightFunctionValues_B = new DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    // Create array for 'weightFunctionValues' Backwards messages.
                    weightFunctionValues_B[d, q] = new DistributionStructArray<Gaussian, double>(this.n);
                    for (int _ind0 = 0; _ind0 < N; _ind0++)
                    {
                        weightFunctionValues_B[d, q][_ind0] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            DistributionRefArray2D<VectorGaussian, Vector> weightFunctions_F = default(DistributionRefArray2D<VectorGaussian, Vector>);
            // Create array for 'weightFunctions' Forwards messages.
            weightFunctions_F = new DistributionRefArray2D<VectorGaussian, Vector>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    weightFunctions_F[d, q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(this.n));
                }
            }
            VectorGaussian _hoist3 = default(VectorGaussian);
            for (int q = 0; q < Q; q++)
            {
                for (int d = 0; d < D; d++)
                {
                    _hoist3 = ArrayHelper.CopyStorage<VectorGaussian>(weightFunctions_F[d, q]);
                    q = this.q - 1;
                    d = this.d - 1;
                }
            }
            _hoist3 = VectorGaussianScaledPrecisionOp.SampleAverageLogarithm(1, this.k_weights_inverse, _hoist3);
            // Message to marginal of 'weightFunctions'
            DistributionRefArray2D<VectorGaussian, Vector> weightFunctions_marginal_B = default(DistributionRefArray2D<VectorGaussian, Vector>);
            // Create array for 'weightFunctions_marginal' Backwards messages.
            weightFunctions_marginal_B = new DistributionRefArray2D<VectorGaussian, Vector>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    weightFunctions_marginal_B[d, q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(this.n));
                }
            }
            // Create array for replicates of 'sum_F'
            Gaussian[][] sum_F = new Gaussian[this.n][];
            for (int n = 0; n < N; n++)
            {
                // Create array for replicates of 'sum_F'
                sum_F[n] = new Gaussian[this.d];
                for (int d = 0; d < D; d++)
                {
                    sum_F[n][d] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
            }
            // Create array for replicates of 'noisePrecision_rep0_rep0_B'
            DistributionStructArray<Gamma, double>[] noisePrecision_rep0_rep0_B = new DistributionStructArray<Gamma, double>[this.n];
            for (int n = 0; n < N; n++)
            {
                // Create array for 'noisePrecision_rep0_rep0' Backwards messages.
                noisePrecision_rep0_rep0_B[n] = new DistributionStructArray<Gamma, double>(this.d);
                for (int d = 0; d < D; d++)
                {
                    noisePrecision_rep0_rep0_B[n][d] = ArrayHelper.MakeUniform<Gamma>(Gamma.Uniform());
                }
            }
            DistributionStructArray<Gamma, double> noisePrecision_rep0_B = default(DistributionStructArray<Gamma, double>);
            // Create array for 'noisePrecision_rep0' Backwards messages.
            noisePrecision_rep0_B = new DistributionStructArray<Gamma, double>(this.n);
            for (int n = 0; n < N; n++)
            {
                noisePrecision_rep0_B[n] = ArrayHelper.MakeUniform<Gamma>(Gamma.Uniform());
            }
            // Message from use of 'noisePrecision'
            Gamma noisePrecision_use_B = ArrayHelper.MakeUniform<Gamma>(Gamma.Uniform());
            Gamma noisePrecision_F = ArrayHelper.MakeUniform<Gamma>(Gamma.Uniform());
            // Message to 'noisePrecision' from GammaFromShapeAndRate factor
            noisePrecision_F = GammaFromShapeAndRateOp.YAverageLogarithm(10, 1);
            for (int q = 0; q < Q; q++)
            {
                for (int d = 0; d < D; d++)
                {
                    // Message to 'weightFunctions_marginal' from Variable factor
                    weightFunctions_marginal_B[d, q] = VariableVmpBufferOp.MarginalAverageLogarithm<VectorGaussian>(this.weightFunctions_use_B[d, q], _hoist3, weightFunctions_marginal_B[d, q]);
                    // Message to 'weightFunctionValues' from ArrayFromVector factor
                    weightFunctionValues_F[d, q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(weightFunctions_marginal_B[d, q], weightFunctionValues_F[d, q]);
                }
                // Message to 'nodeFunctionValues' from ArrayFromVector factor
                nodeFunctionValues_F[q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(this.nodeFunctions_use_F[q], nodeFunctionValues_F[q]);
                for (int n = 0; n < N; n++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'temp' from Product factor
                        temp_F[n][d][q] = GaussianProductVmpOp.ProductAverageLogarithm(weightFunctionValues_F[d, q][n], nodeFunctionValues_F[q][n]);
                    }
                }
            }
            for (int n = 0; n < N; n++)
            {
                for (int d = 0; d < D; d++)
                {
                    // Message to 'sum' from Sum factor
                    sum_F[n][d] = FastSumOp.SumAverageLogarithm(temp_F[n][d]);
                    // Message to 'noisePrecision_rep0_rep0' from Gaussian factor
                    noisePrecision_rep0_rep0_B[n][d] = GaussianOp.PrecisionAverageLogarithm(this.ObservedData[d, n], sum_F[n][d]);
                }
                // Message to 'noisePrecision_rep0' from Replicate factor
                noisePrecision_rep0_B[n] = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep0_rep0_B[n], noisePrecision_rep0_B[n]);
            }
            // Message to 'noisePrecision_use' from Replicate factor
            noisePrecision_use_B = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep0_B, noisePrecision_use_B);
            // Message to 'noisePrecision_marginal' from Variable factor
            this.noisePrecision_marginal_B = VariableVmpBufferOp.MarginalAverageLogarithm<Gamma>(noisePrecision_use_B, noisePrecision_F, this.noisePrecision_marginal_B);
            for (int n = 0; n < N; n++)
            {
                for (int d = 0; d < D; d++)
                {
                    // Message to 'sum' from Gaussian factor
                    sum_B[n][d] = GaussianOp.MeanAverageLogarithm(this.ObservedData[d, n], this.noisePrecision_marginal_B);
                }
            }
            for (int iteration = this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone; iteration < numberOfIterations; iteration++)
            {
                for (int q = 0; q < Q; q++)
                {
                    // Message to 'nodeFunctionValues' from ArrayFromVector factor
                    nodeFunctionValues_F[q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(this.nodeFunctions_use_F[q], nodeFunctionValues_F[q]);
                    for (int n = 0; n < N; n++)
                    {
                        for (int d = 0; d < D; d++)
                        {
                            // Message to 'temp' from Product factor
                            temp_F[n][d][q] = GaussianProductVmpOp.ProductAverageLogarithm(weightFunctionValues_F[d, q][n], nodeFunctionValues_F[q][n]);
                        }
                    }
                }
                for (int n = 0; n < N; n++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'temp' from Sum factor
                        this.temp_B[n][d] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(sum_B[n][d], temp_F[n][d], this.temp_B[n][d]);
                        for (int q = 0; q < Q; q++)
                        {
                            // Message to 'weightFunctionValues' from Product factor
                            weightFunctionValues_B[d, q][n] = GaussianProductVmpOp.AAverageLogarithm(this.temp_B[n][d][q], nodeFunctionValues_F[q][n]);
                        }
                    }
                }
                for (int q = 0; q < Q; q++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'weightFunctions_use' from ArrayFromVector factor
                        this.weightFunctions_use_B[d, q] = ArrayFromVectorOp.VectorAverageLogarithm(weightFunctionValues_B[d, q], this.weightFunctions_use_B[d, q]);
                        // Message to 'weightFunctions_marginal' from Variable factor
                        weightFunctions_marginal_B[d, q] = VariableVmpBufferOp.MarginalAverageLogarithm<VectorGaussian>(this.weightFunctions_use_B[d, q], _hoist3, weightFunctions_marginal_B[d, q]);
                        // Message to 'weightFunctionValues' from ArrayFromVector factor
                        weightFunctionValues_F[d, q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(weightFunctions_marginal_B[d, q], weightFunctionValues_F[d, q]);
                        for (int n = 0; n < N; n++)
                        {
                            // Message to 'temp' from Product factor
                            temp_F[n][d][q] = GaussianProductVmpOp.ProductAverageLogarithm(weightFunctionValues_F[d, q][n], nodeFunctionValues_F[q][n]);
                        }
                    }
                }
                for (int n = 0; n < N; n++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'sum' from Sum factor
                        sum_F[n][d] = FastSumOp.SumAverageLogarithm(temp_F[n][d]);
                        // Message to 'noisePrecision_rep0_rep0' from Gaussian factor
                        noisePrecision_rep0_rep0_B[n][d] = GaussianOp.PrecisionAverageLogarithm(this.ObservedData[d, n], sum_F[n][d]);
                    }
                    // Message to 'noisePrecision_rep0' from Replicate factor
                    noisePrecision_rep0_B[n] = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep0_rep0_B[n], noisePrecision_rep0_B[n]);
                }
                // Message to 'noisePrecision_use' from Replicate factor
                noisePrecision_use_B = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep0_B, noisePrecision_use_B);
                // Message to 'noisePrecision_marginal' from Variable factor
                this.noisePrecision_marginal_B = VariableVmpBufferOp.MarginalAverageLogarithm<Gamma>(noisePrecision_use_B, noisePrecision_F, this.noisePrecision_marginal_B);
                for (int q = 0; q < Q; q++)
                {
                    // Message to 'ev_selector_cases_0_rep1_uses' from VectorGaussianScaled factor
                    nodeFunctions_B_q__SampleVariance[q] = VectorGaussianScaledPrecisionOp.SampleVariance(this.nodeFunctions_marginal_B[q], nodeFunctions_B_q__SampleVariance[q]);
                    // Message to 'ev_selector_cases_0_rep1_uses' from VectorGaussianScaled factor
                    nodeFunctions_B_q__SampleMean[q] = VectorGaussianScaledPrecisionOp.SampleMean(this.nodeFunctions_marginal_B[q], nodeFunctions_B_q__SampleVariance[q], nodeFunctions_B_q__SampleMean[q]);
                    // Message to 'nodeSignalPrecisions_use' from VectorGaussianScaled factor
                    nodeSignalPrecisions_use_B[q] = VectorGaussianScaledPrecisionOp.ScalingAverageLogarithm(this.k_node_inverse, nodeFunctions_B_q__SampleMean[q], nodeFunctions_B_q__SampleVariance[q]);
                    // Message to 'nodeSignalPrecisions_marginal' from Variable factor
                    this.nodeSignalPrecisions_marginal_B[q] = VariableVmpBufferOp.MarginalAverageLogarithm<Gamma>(nodeSignalPrecisions_use_B[q], _hoist0, this.nodeSignalPrecisions_marginal_B[q]);
                    // Message to 'nodeFunctions' from VectorGaussianScaled factor
                    nodeFunctions_F[q] = VectorGaussianScaledPrecisionOp.SampleAverageLogarithm(this.nodeSignalPrecisions_marginal_B[q], this.k_node_inverse, nodeFunctions_F[q]);
                }
                for (int n = 0; n < N; n++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'sum' from Gaussian factor
                        sum_B[n][d] = GaussianOp.MeanAverageLogarithm(this.ObservedData[d, n], this.noisePrecision_marginal_B);
                        // Message to 'temp' from Sum factor
                        this.temp_B[n][d] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(sum_B[n][d], temp_F[n][d], this.temp_B[n][d]);
                        for (int q = 0; q < Q; q++)
                        {
                            // Message to 'nodeFunctionValues_rep0' from Product factor
                            nodeFunctionValues_rep0_B[q][n][d] = GaussianProductVmpOp.BAverageLogarithm(this.temp_B[n][d][q], weightFunctionValues_F[d, q][n]);
                        }
                    }
                    for (int q = 0; q < Q; q++)
                    {
                        // Message to 'nodeFunctionValues' from Replicate factor
                        nodeFunctionValues_B[q][n] = ReplicateOp.DefAverageLogarithm<Gaussian>(nodeFunctionValues_rep0_B[q][n], nodeFunctionValues_B[q][n]);
                    }
                }
                for (int q = 0; q < Q; q++)
                {
                    // Message to 'nodeFunctions_use' from ArrayFromVector factor
                    nodeFunctions_use_B[q] = ArrayFromVectorOp.VectorAverageLogarithm(nodeFunctionValues_B[q], nodeFunctions_use_B[q]);
                    // Message to 'nodeFunctions_marginal' from Variable factor
                    this.nodeFunctions_marginal_B[q] = VariableVmpBufferOp.MarginalAverageLogarithm<VectorGaussian>(nodeFunctions_use_B[q], nodeFunctions_F[q], this.nodeFunctions_marginal_B[q]);
                    // Message to 'nodeFunctions_use' from Variable factor
                    this.nodeFunctions_use_F[q] = Factor.Copy<VectorGaussian>(this.nodeFunctions_marginal_B[q]);
                }
                this.OnProgressChanged(new ProgressChangedEventArgs(iteration));
            }
            Bernoulli[] ev_selector_cases_0_uses_B = default(Bernoulli[]);
            // Create array for 'ev_selector_cases_0_uses' Backwards messages.
            ev_selector_cases_0_uses_B = new Bernoulli[32];
            for (int _ind = 0; _ind < 32; _ind++)
            {
                ev_selector_cases_0_uses_B[_ind] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            }
            // Message to 'ev_selector_cases_0_uses' from GammaFromShapeAndRate factor
            ev_selector_cases_0_uses_B[3] = Bernoulli.FromLogOdds(GammaFromShapeAndRateOp.AverageLogFactor(this.noisePrecision_marginal_B, 10, 1));
            // Message to 'ev_selector_cases_0_uses' from Variable factor
            ev_selector_cases_0_uses_B[4] = Bernoulli.FromLogOdds(VariableVmpBufferOp.AverageLogFactor<Gamma>(this.noisePrecision_marginal_B));
            DistributionStructArray<Bernoulli, bool>[] ev_selector_cases_0_rep0_uses_B = default(DistributionStructArray<Bernoulli, bool>[]);
            // Create array for 'ev_selector_cases_0_rep0_uses' Backwards messages.
            ev_selector_cases_0_rep0_uses_B = new DistributionStructArray<Bernoulli, bool>[2];
            for (int _ind = 0; _ind < 2; _ind++)
            {
                // Create array for 'ev_selector_cases_0_rep0_uses' Backwards messages.
                ev_selector_cases_0_rep0_uses_B[_ind] = new DistributionStructArray<Bernoulli, bool>(this.q);
                for (int q = 0; q < Q; q++)
                {
                    ev_selector_cases_0_rep0_uses_B[_ind][q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                }
            }
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep0_uses' from GammaFromShapeAndRate factor
                ev_selector_cases_0_rep0_uses_B[0][q] = Bernoulli.FromLogOdds(GammaFromShapeAndRateOp.AverageLogFactor(this.nodeSignalPrecisions_marginal_B[q], 0.1, 0.1));
                // Message to 'ev_selector_cases_0_rep0_uses' from Variable factor
                ev_selector_cases_0_rep0_uses_B[1][q] = Bernoulli.FromLogOdds(VariableVmpBufferOp.AverageLogFactor<Gamma>(this.nodeSignalPrecisions_marginal_B[q]));
            }
            DistributionStructArray<Bernoulli, bool> ev_selector_cases_0_rep0_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases_0_rep0' Backwards messages.
            ev_selector_cases_0_rep0_B = new DistributionStructArray<Bernoulli, bool>(this.q);
            for (int q = 0; q < Q; q++)
            {
                ev_selector_cases_0_rep0_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            }
            // Message to 'ev_selector_cases_0_rep0' from Replicate factor
            ev_selector_cases_0_rep0_B = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli, bool>>(ev_selector_cases_0_rep0_uses_B, ev_selector_cases_0_rep0_B);
            // Message to 'ev_selector_cases_0_uses' from Replicate factor
            ev_selector_cases_0_uses_B[6] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep0_B, ev_selector_cases_0_uses_B[6]);
            // Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
            // Create array for replicates of 'nodeFunctions_B_q__SampleMean_ESamplePrecisionSample'
            double[] nodeFunctions_B_q__SampleMean_ESamplePrecisionSample = new double[this.q];
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep1_uses' from VectorGaussianScaled factor
                nodeFunctions_B_q__SampleMean_ESamplePrecisionSample[q] = VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(nodeFunctions_B_q__SampleMean[q], nodeFunctions_B_q__SampleVariance[q], this.k_node_inverse);
            }
            double K_node_inverse_logDet = default(double);
            K_node_inverse_logDet = VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(this.k_node_inverse);
            DistributionStructArray<Bernoulli, bool>[] ev_selector_cases_0_rep1_uses_B = default(DistributionStructArray<Bernoulli, bool>[]);
            // Create array for 'ev_selector_cases_0_rep1_uses' Backwards messages.
            ev_selector_cases_0_rep1_uses_B = new DistributionStructArray<Bernoulli, bool>[2];
            for (int _ind = 0; _ind < 2; _ind++)
            {
                // Create array for 'ev_selector_cases_0_rep1_uses' Backwards messages.
                ev_selector_cases_0_rep1_uses_B[_ind] = new DistributionStructArray<Bernoulli, bool>(this.q);
                for (int q = 0; q < Q; q++)
                {
                    ev_selector_cases_0_rep1_uses_B[_ind][q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                }
            }
            double L_K_node = 0; // current likelihood w.r.t. node log lengthscale
            for (int q = 0; q < Q; q++)
            {
                double temp = VectorGaussianScaledPrecisionOp.AverageLogFactor(nodeFunctions_B_q__SampleMean[q], this.nodeSignalPrecisions_marginal_B[q], nodeFunctions_B_q__SampleMean_ESamplePrecisionSample[q], K_node_inverse_logDet);
                L_K_node += temp; 
                // Message to 'ev_selector_cases_0_rep1_uses' from VectorGaussianScaled factor
                ev_selector_cases_0_rep1_uses_B[0][q] = Bernoulli.FromLogOdds(temp);
                // Message to 'ev_selector_cases_0_rep1_uses' from Variable factor
                ev_selector_cases_0_rep1_uses_B[1][q] = Bernoulli.FromLogOdds(VariableVmpBufferOp.AverageLogFactor<VectorGaussian>(this.nodeFunctions_marginal_B[q]));
            }

            //---------------------- OPTIMISE NODE LOG LENGTH SCALE ---------------------------------
            if (Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone 
                >= this.firstIterationToOptimiseNodeLengthScale)
            {
                OptimiseNodeLogLengthscale(nodeFunctions_B_q__SampleMean, nodeFunctions_B_q__SampleMean_ESamplePrecisionSample, nodeFunctions_B_q__SampleVariance, L_K_node);
                this.k_node_inverse = K_node_inverse_func(nodeLogLengthScale);
            }
            // don't need to recalculate buffers: this will be done in the next iteration anyway

            DistributionStructArray<Bernoulli, bool> ev_selector_cases_0_rep1_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases_0_rep1' Backwards messages.
            ev_selector_cases_0_rep1_B = new DistributionStructArray<Bernoulli, bool>(this.q);
            for (int q = 0; q < Q; q++)
            {
                ev_selector_cases_0_rep1_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            }
            // Message to 'ev_selector_cases_0_rep1' from Replicate factor
            ev_selector_cases_0_rep1_B = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli, bool>>(ev_selector_cases_0_rep1_uses_B, ev_selector_cases_0_rep1_B);
            // Message to 'ev_selector_cases_0_uses' from Replicate factor
            ev_selector_cases_0_uses_B[10] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep1_B, ev_selector_cases_0_uses_B[10]);
            // Buffer for VectorGaussianScaledPrecisionOp.SampleMean
            // Create array for replicates of 'weightFunctions_B_d__q__SampleVariance'
            PositiveDefiniteMatrix[][] weightFunctions_B_d__q__SampleVariance = new PositiveDefiniteMatrix[this.q][];
            for (int q = 0; q < Q; q++)
            {
                // Create array for replicates of 'weightFunctions_B_d__q__SampleVariance'
                weightFunctions_B_d__q__SampleVariance[q] = new PositiveDefiniteMatrix[this.d];
                for (int d = 0; d < D; d++)
                {
                    // Message to 'ev_selector_cases_0_rep4_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleVariance[q][d] = VectorGaussianScaledPrecisionOp.SampleVarianceInit(weightFunctions_marginal_B[d, q]);
                    // Message to 'ev_selector_cases_0_rep4_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleVariance[q][d] = VectorGaussianScaledPrecisionOp.SampleVariance(weightFunctions_marginal_B[d, q], weightFunctions_B_d__q__SampleVariance[q][d]);
                }
            }
            // Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
            // Create array for replicates of 'weightFunctions_B_d__q__SampleMean'
            Vector[][] weightFunctions_B_d__q__SampleMean = new Vector[this.q][];
            for (int q = 0; q < Q; q++)
            {
                // Create array for replicates of 'weightFunctions_B_d__q__SampleMean'
                weightFunctions_B_d__q__SampleMean[q] = new Vector[this.d];
                for (int d = 0; d < D; d++)
                {
                    // Message to 'ev_selector_cases_0_rep4_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleMean[q][d] = VectorGaussianScaledPrecisionOp.SampleMeanInit(weightFunctions_marginal_B[d, q]);
                    // Message to 'ev_selector_cases_0_rep4_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleMean[q][d] = VectorGaussianScaledPrecisionOp.SampleMean(weightFunctions_marginal_B[d, q], weightFunctions_B_d__q__SampleVariance[q][d], weightFunctions_B_d__q__SampleMean[q][d]);
                }
            }
            // Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
            // Create array for replicates of 'weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample'
            double[][] weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample = new double[this.q][];
            for (int q = 0; q < Q; q++)
            {
                // Create array for replicates of 'weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample'
                weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample[q] = new double[this.d];
                for (int d = 0; d < D; d++)
                {
                    // Message to 'ev_selector_cases_0_rep4_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample[q][d] = VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(weightFunctions_B_d__q__SampleMean[q][d], weightFunctions_B_d__q__SampleVariance[q][d], this.k_weights_inverse);
                }
            }
            double K_weight_inverse_logDet = default(double);
            K_weight_inverse_logDet = VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(this.k_weights_inverse);
            // Create array for replicates of 'ev_selector_cases_0_rep4_rep0_uses_B'
            DistributionStructArray<Bernoulli, bool>[][] ev_selector_cases_0_rep4_rep0_uses_B = new DistributionStructArray<Bernoulli, bool>[this.q][];
            double L_K_weight = 0; 
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'ev_selector_cases_0_rep4_rep0_uses' Backwards messages.
                ev_selector_cases_0_rep4_rep0_uses_B[q] = new DistributionStructArray<Bernoulli, bool>[2];
                for (int _ind = 0; _ind < 2; _ind++)
                {
                    // Create array for 'ev_selector_cases_0_rep4_rep0_uses' Backwards messages.
                    ev_selector_cases_0_rep4_rep0_uses_B[q][_ind] = new DistributionStructArray<Bernoulli, bool>(this.d);
                    for (int d = 0; d < D; d++)
                    {
                        ev_selector_cases_0_rep4_rep0_uses_B[q][_ind][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                    }
                }
                for (int d = 0; d < D; d++)
                {
                    // Message to 'ev_selector_cases_0_rep4_rep0_uses' from VectorGaussianScaled factor
                    double temp = VectorGaussianScaledPrecisionOp.AverageLogFactor(weightFunctions_B_d__q__SampleMean[q][d], 1, weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample[q][d], K_weight_inverse_logDet); 
                    ev_selector_cases_0_rep4_rep0_uses_B[q][0][d] = Bernoulli.FromLogOdds(temp);
                    L_K_weight += temp; 
                    // Message to 'ev_selector_cases_0_rep4_rep0_uses' from Variable factor
                    ev_selector_cases_0_rep4_rep0_uses_B[q][1][d] = Bernoulli.FromLogOdds(VariableVmpBufferOp.AverageLogFactor<VectorGaussian>(weightFunctions_marginal_B[d, q]));
                }
            }

            // Optimise weight ll
            if (Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone >=
                this.firstIterationToOptimiseWeightLengthScale)
            {
                OptimiseWeightLogLengthscale(weightFunctions_B_d__q__SampleMean, weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample,
                    weightFunctions_B_d__q__SampleVariance, L_K_weight);
                this.k_weights_inverse = K_weight_inverse_func(this.weightsLogLengthScale);
            }

            // Create array for replicates of 'ev_selector_cases_0_rep4_rep0_B'
            DistributionStructArray<Bernoulli, bool>[] ev_selector_cases_0_rep4_rep0_B = new DistributionStructArray<Bernoulli, bool>[this.q];
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'ev_selector_cases_0_rep4_rep0' Backwards messages.
                ev_selector_cases_0_rep4_rep0_B[q] = new DistributionStructArray<Bernoulli, bool>(this.d);
                for (int d = 0; d < D; d++)
                {
                    ev_selector_cases_0_rep4_rep0_B[q][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                }
                // Message to 'ev_selector_cases_0_rep4_rep0' from Replicate factor
                ev_selector_cases_0_rep4_rep0_B[q] = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli, bool>>(ev_selector_cases_0_rep4_rep0_uses_B[q], ev_selector_cases_0_rep4_rep0_B[q]);
            }
            DistributionStructArray<Bernoulli, bool> ev_selector_cases_0_rep4_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases_0_rep4' Backwards messages.
            ev_selector_cases_0_rep4_B = new DistributionStructArray<Bernoulli, bool>(this.q);
            for (int q = 0; q < Q; q++)
            {
                ev_selector_cases_0_rep4_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                // Message to 'ev_selector_cases_0_rep4' from Replicate factor
                ev_selector_cases_0_rep4_B[q] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep4_rep0_B[q], ev_selector_cases_0_rep4_B[q]);
            }
            // Message to 'ev_selector_cases_0_uses' from Replicate factor
            ev_selector_cases_0_uses_B[17] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep4_B, ev_selector_cases_0_uses_B[17]);
            // Create array for replicates of 'ev_selector_cases_0_rep12_rep0_B'
            DistributionStructArray<Bernoulli, bool>[] ev_selector_cases_0_rep12_rep0_B = new DistributionStructArray<Bernoulli, bool>[this.n];
            for (int n = 0; n < N; n++)
            {
                // Create array for 'ev_selector_cases_0_rep12_rep0' Backwards messages.
                ev_selector_cases_0_rep12_rep0_B[n] = new DistributionStructArray<Bernoulli, bool>(this.d);
                for (int d = 0; d < D; d++)
                {
                    ev_selector_cases_0_rep12_rep0_B[n][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                    // Message to 'ev_selector_cases_0_rep12_rep0' from Gaussian factor
                    ev_selector_cases_0_rep12_rep0_B[n][d] = Bernoulli.FromLogOdds(GaussianOp.AverageLogFactor(this.ObservedData[d, n], sum_F[n][d], this.noisePrecision_marginal_B));
                }
            }
            DistributionStructArray<Bernoulli, bool> ev_selector_cases_0_rep12_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases_0_rep12' Backwards messages.
            ev_selector_cases_0_rep12_B = new DistributionStructArray<Bernoulli, bool>(this.n);
            for (int n = 0; n < N; n++)
            {
                ev_selector_cases_0_rep12_B[n] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                // Message to 'ev_selector_cases_0_rep12' from Replicate factor
                ev_selector_cases_0_rep12_B[n] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep12_rep0_B[n], ev_selector_cases_0_rep12_B[n]);
            }
            // Message to 'ev_selector_cases_0_uses' from Replicate factor
            ev_selector_cases_0_uses_B[28] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep12_B, ev_selector_cases_0_uses_B[28]);
            Bernoulli ev_selector_cases_0_B = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            // Message to 'ev_selector_cases_0' from Replicate factor
            ev_selector_cases_0_B = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_uses_B, ev_selector_cases_0_B);
            DistributionStructArray<Bernoulli, bool> ev_selector_cases_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases' Backwards messages.
            ev_selector_cases_B = new DistributionStructArray<Bernoulli, bool>(2);
            for (int _ind0 = 0; _ind0 < 2; _ind0++)
            {
                ev_selector_cases_B[_ind0] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            }
            // Message to 'ev_selector_cases' from Copy factor
            ev_selector_cases_B[0] = Factor.Copy<Bernoulli>(ev_selector_cases_0_B);
            Bernoulli ev_selector_B = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
            // Message to 'ev_selector' from Cases factor
            ev_selector_B = CasesOp.BAverageLogarithm(ev_selector_cases_B);
            // Message to 'ev_marginal' from Variable factor
            this.ev_marginal_B = VariableVmpBufferOp.MarginalAverageLogarithm<Bernoulli>(ev_selector_B, vBernoulli0, this.ev_marginal_B);
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_K_node_inverse_nodeFunctionsInitVar_K_weights0_iterationsDone = numberOfIterations;
        }

        /// <summary>
        /// Returns the marginal distribution for 'ev' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public Bernoulli EvMarginal()
        {
            return this.ev_marginal_B;
        }

        /// <summary>
        /// Returns the marginal distribution for 'noisePrecision' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public Gamma NoisePrecisionMarginal()
        {
            return this.noisePrecision_marginal_B;
        }

        /// <summary>
        /// Returns the marginal distribution for 'nodeSignalPrecisions' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public DistributionStructArray<Gamma, double> NodeSignalPrecisionsMarginal()
        {
            return this.nodeSignalPrecisions_marginal_B;
        }

        #endregion

        #region Events
        /// <summary>Event that is fired when the progress of inference changes, typically at the end of one iteration of the inference algorithm.</summary>
        public event EventHandler<ProgressChangedEventArgs> ProgressChanged;

        #endregion

    }

}
