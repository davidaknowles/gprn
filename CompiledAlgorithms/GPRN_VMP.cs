using System;
using System.Linq; 
using MicrosoftResearch.Infer;
using MicrosoftResearch.Infer.Distributions;
using MicrosoftResearch.Infer.Maths;
using MicrosoftResearch.Infer.Collections;
using gpnetworkVB;
using MicrosoftResearch.Infer.Factors;

namespace gpnetworkVB
{
    /// <summary>
    /// Class for performing inference in model 'GPRN' using algorithm 'VariationalMessagePassing'.
    /// This is the basic GPRN model with isotropic noise, no node noise and no mean function.
    /// </summary>
    /// <remarks>
    /// The easiest way to use this class is to wrap an instance in a CompiledAlgorithm object and use
    /// the methods on CompiledAlgorithm to set parameters and execute inference.
    /// 
    /// If you instead wish to use this class directly, you must perform the following steps:
    /// 1) Create an instance of the class
    /// 2) Set the value of any externally-set fields e.g. data, priors
    /// 3) Call the Execute(numberOfIterations) method
    /// 4) Use the XXXMarginal() methods to retrieve posterior marginals for different variables.
    /// 
    /// Generated by Infer.NET 2.4 beta 2 at 21:08 on 17 September 2011.
    /// </remarks>
    public class GPRN_VMP : INetworkModel
    {
        public bool HasMeanFunctions() { return false; }

        #region Fields

        public KernelOptimiser nodeKernelOptimiser { get; set; }
        public KernelOptimiser weightKernelOptimiser { get; set; }

        /// <summary>Field backing the NumberOfIterationsDone property</summary>
        private int numberOfIterationsDone;
        /// <summary>Field backing the noisePrecisionPrior property</summary>
        private Gamma NoisePrecisionPrior;
        /// <summary>Field backing the Q property</summary>
        private int q;
        /// <summary>Field backing the N property</summary>
        private int n;
        /// <summary>Field backing the nodeFunctionsInitVar property</summary>
        private IDistribution<Vector[]> NodeFunctionsInitVar;
        /// <summary>Field backing the nodeSignalPrecisionsPrior property</summary>
        private Gamma NodeSignalPrecisionsPrior;
        /// <summary>Field backing the K_node_inverse property</summary>
        private PositiveDefiniteMatrix k_node_inverse;
        /// <summary>Field backing the D property</summary>
        private int d;
        /// <summary>Field backing the K_weights_inverse property</summary>
        private PositiveDefiniteMatrix k_weights_inverse;
        /// <summary>Field backing the observedData property</summary>
        private double[,] ObservedData;
        /// <summary>The number of iterations last computed by Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0. Set this to zero to force re-execution of Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0</summary>
        public int Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone;
        /// <summary>The number of iterations last computed by Constant. Set this to zero to force re-execution of Constant</summary>
        public int Constant_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2. Set this to zero to force re-execution of Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2</summary>
        public int Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_iterationsDone;
        /// <summary>True if Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2 has performed initialisation. Set this to false to force re-execution of Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2</summary>
        public bool Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised;
        /// <summary>The number of iterations last computed by Changed_N. Set this to zero to force re-execution of Changed_N</summary>
        public int Changed_N_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_N_D. Set this to zero to force re-execution of Changed_N_D</summary>
        public int Changed_N_D_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_N_D_Q. Set this to zero to force re-execution of Changed_N_D_Q</summary>
        public int Changed_N_D_Q_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6. Set this to zero to force re-execution of Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6</summary>
        public int Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone;
        /// <summary>True if Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6 has performed initialisation. Set this to false to force re-execution of Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6</summary>
        public bool Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised;
        /// <summary>The number of iterations last computed by Changed_D_Q. Set this to zero to force re-execution of Changed_D_Q</summary>
        public int Changed_D_Q_iterationsDone;
        /// <summary>The number of iterations last computed by Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8. Set this to zero to force re-execution of Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8</summary>
        public int Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_iterationsDone;
        /// <summary>True if Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8 has performed initialisation. Set this to false to force re-execution of Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8</summary>
        public bool Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised;
        public DistributionStructArray<Gaussian, double>[][] temp_B;
        /// <summary>Message to marginal of 'nodeFunctions'</summary>
        public DistributionRefArray<VectorGaussian, Vector> nodeFunctions_marginal_F;
        /// <summary>Message from use of 'weightFunctions'</summary>
        public DistributionRefArray2D<VectorGaussian, Vector> weightFunctions_use_B;
        /// <summary>Message to use of 'nodeFunctions'</summary>
        public DistributionRefArray<VectorGaussian, Vector> nodeFunctions_use_F;
        /// <summary>Message to marginal of 'ev'</summary>
        public Bernoulli ev_marginal_F;
        /// <summary>Message to marginal of 'nodeSignalPrecisions'</summary>
        public DistributionStructArray<Gamma, double> nodeSignalPrecisions_marginal_F;
        /// <summary>Message to marginal of 'noisePrecision'</summary>
        public Gamma noisePrecision_marginal_F;
        public DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]> nodeFunctionValues_F;
        public DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]> weightFunctionValues_F;
        public DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]> nodeFunctionValuesPredictive_F;
        public DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]> weightFunctionValuesPredictive_F;
        #endregion

        #region Properties
        /// <summary>The number of iterations done from the initial state</summary>
        public int NumberOfIterationsDone
        {
            get
            {
                return this.numberOfIterationsDone;
            }
        }

        /// <summary>The externally-specified value of 'noisePrecisionPrior'</summary>
        public Gamma noisePrecisionPrior
        {
            get
            {
                return this.NoisePrecisionPrior;
            }
            set
            {
                if (this.NoisePrecisionPrior != value)
                {
                    this.NoisePrecisionPrior = value;
                    this.numberOfIterationsDone = 0;
                    this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised = false;
                    this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = false;
                    this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                    this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
                }
            }
        }

        /// <summary>The externally-specified value of 'Q'</summary>
        public int Q
        {
            get
            {
                return this.q;
            }
            set
            {
                if (this.q != value)
                {
                    this.q = value;
                    this.numberOfIterationsDone = 0;
                    this.Changed_N_D_Q_iterationsDone = 0;
                    this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone = 0;
                    this.Changed_D_Q_iterationsDone = 0;
                    this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_iterationsDone = 0;
                    this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                    this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
                }
            }
        }

        /// <summary>The externally-specified value of 'N'</summary>
        public int N
        {
            get
            {
                return this.n;
            }
            set
            {
                if (this.n != value)
                {
                    this.n = value;
                    this.numberOfIterationsDone = 0;
                    this.Changed_N_iterationsDone = 0;
                    this.Changed_N_D_iterationsDone = 0;
                    this.Changed_N_D_Q_iterationsDone = 0;
                    this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone = 0;
                    this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = false;
                    this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                    this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
                }
            }
        }

        /// <summary>The externally-specified value of 'nodeFunctionsInitVar'</summary>
        public IDistribution<Vector[]> nodeFunctionsInitVar
        {
            get
            {
                return this.NodeFunctionsInitVar;
            }
            set
            {
                this.NodeFunctionsInitVar = value;
                this.numberOfIterationsDone = 0;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised = false;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_iterationsDone = 0;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
            }
        }

        /// <summary>The externally-specified value of 'nodeSignalPrecisionsPrior'</summary>
        public Gamma nodeSignalPrecisionsPrior
        {
            get
            {
                return this.NodeSignalPrecisionsPrior;
            }
            set
            {
                if (this.NodeSignalPrecisionsPrior != value)
                {
                    this.NodeSignalPrecisionsPrior = value;
                    this.numberOfIterationsDone = 0;
                    this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised = false;
                    this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = false;
                    this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                    this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
                }
            }
        }

        /// <summary>The externally-specified value of 'K_node_inverse'</summary>
        public PositiveDefiniteMatrix K_node_inverse
        {
            get
            {
                return this.k_node_inverse;
            }
            set
            {
                this.k_node_inverse = value;
                this.numberOfIterationsDone = 0;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised = false;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
            }
        }

        /// <summary>The externally-specified value of 'D'</summary>
        public int D
        {
            get
            {
                return this.d;
            }
            set
            {
                if (this.d != value)
                {
                    this.d = value;
                    this.numberOfIterationsDone = 0;
                    this.Changed_N_D_iterationsDone = 0;
                    this.Changed_N_D_Q_iterationsDone = 0;
                    this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone = 0;
                    this.Changed_D_Q_iterationsDone = 0;
                    this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_iterationsDone = 0;
                    this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                    this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
                }
            }
        }

        /// <summary>The externally-specified value of 'K_weights_inverse'</summary>
        public PositiveDefiniteMatrix K_weights_inverse
        {
            get
            {
                return this.k_weights_inverse;
            }
            set
            {
                this.k_weights_inverse = value;
                this.numberOfIterationsDone = 0;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised = false;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
            }
        }

        /// <summary>The externally-specified value of 'observedData'</summary>
        public double[,] observedData
        {
            get
            {
                return this.ObservedData;
            }
            set
            {
                if ((value != null) && (((value.GetLength(0)) != this.d) || ((value.GetLength(1)) != this.n)))
                {
                    throw new ArgumentException(((("Provided array of size " + (((("(" + (value.GetLength(0))) + ",") + (value.GetLength(1))) + ")")) + " when size ") + (((("(" + this.d) + ",") + this.n) + ")")) + " was expected");
                }
                this.ObservedData = value;
                this.numberOfIterationsDone = 0;
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised = false;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
            }
        }

        #endregion

        #region Methods
        /// <summary>Get the observed value of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        public object GetObservedValue(string variableName)
        {
            if (variableName == "noisePrecisionPrior")
            {
                return this.noisePrecisionPrior;
            }
            if (variableName == "Q")
            {
                return this.Q;
            }
            if (variableName == "N")
            {
                return this.N;
            }
            if (variableName == "nodeFunctionsInitVar")
            {
                return this.nodeFunctionsInitVar;
            }
            if (variableName == "nodeSignalPrecisionsPrior")
            {
                return this.nodeSignalPrecisionsPrior;
            }
            if (variableName == "K_node_inverse")
            {
                return this.K_node_inverse;
            }
            if (variableName == "D")
            {
                return this.D;
            }
            if (variableName == "K_weights_inverse")
            {
                return this.K_weights_inverse;
            }
            if (variableName == "observedData")
            {
                return this.observedData;
            }
            throw new ArgumentException("Not an observed variable name: " + variableName);
        }

        /// <summary>Set the observed value of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        /// <param name="value">Observed value</param>
        public void SetObservedValue(string variableName, object value)
        {
            if (variableName == "noisePrecisionPrior")
            {
                this.noisePrecisionPrior = (Gamma)value;
                return;
            }
            if (variableName == "Q")
            {
                this.Q = (int)value;
                return;
            }
            if (variableName == "N")
            {
                this.N = (int)value;
                return;
            }
            if (variableName == "nodeFunctionsInitVar")
            {
                this.nodeFunctionsInitVar = (IDistribution<Vector[]>)value;
                return;
            }
            if (variableName == "nodeSignalPrecisionsPrior")
            {
                this.nodeSignalPrecisionsPrior = (Gamma)value;
                return;
            }
            if (variableName == "K_node_inverse")
            {
                this.K_node_inverse = (PositiveDefiniteMatrix)value;
                return;
            }
            if (variableName == "D")
            {
                this.D = (int)value;
                return;
            }
            if (variableName == "K_weights_inverse")
            {
                this.K_weights_inverse = (PositiveDefiniteMatrix)value;
                return;
            }
            if (variableName == "observedData")
            {
                this.observedData = (double[,])value;
                return;
            }
            throw new ArgumentException("Not an observed variable name: " + variableName);
        }

        /// <summary>The marginal distribution of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        public object Marginal(string variableName)
        {
            if (variableName == "ev")
            {
                return this.EvMarginal();
            }
            if (variableName == "noisePrecision")
            {
                return this.NoisePrecisionMarginal();
            }
            if (variableName == "noisePrecisionArray")
            {
                return System.Linq.Enumerable.Range(0, D).Select(o => this.NoisePrecisionMarginal()).ToArray();
            }
            if (variableName == "nodeSignalPrecisions")
            {
                return this.NodeSignalPrecisionsMarginal();
            }
            if (variableName == "nodeFunctionValues")
            {
                return this.NodeFunctionValuesMarginal();
            }
            if (variableName == "nodeFunctionValuesPredictive")
            {
                return this.NodeFunctionValuesPredictiveMarginal();
            }
            if (variableName == "weightFunctionValues")
            {
                return this.WeightFunctionValuesMarginal();
            }
            if (variableName == "weightFunctionValuesPredictive")
            {
                return this.WeightFunctionValuesPredictiveMarginal();
            }
            throw new ArgumentException("This class was not built to infer " + variableName);
        }

        public T Marginal<T>(string variableName)
        {
            return Distribution.ChangeType<T>(this.Marginal(variableName));
        }

        /// <summary>The query-specific marginal distribution of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        /// <param name="query">QueryType name. For example, GibbsSampling answers 'Marginal', 'Samples', and 'Conditionals' queries</param>
        public object Marginal(string variableName, string query)
        {
            if (query == "Marginal")
            {
                return this.Marginal(variableName);
            }
            throw new ArgumentException(((("This class was not built to infer \'" + variableName) + "\' with query \'") + query) + "\'");
        }

        public T Marginal<T>(string variableName, string query)
        {
            return Distribution.ChangeType<T>(this.Marginal(variableName, query));
        }

        /// <summary>The output message of the specified variable.</summary>
        /// <param name="variableName">Variable name</param>
        public object GetOutputMessage(string variableName)
        {
            throw new ArgumentException("This class was not built to compute an output message for " + variableName);
        }

        /// <summary>Update all marginals, by iterating message passing the given number of times</summary>
        /// <param name="numberOfIterations">The number of times to iterate each loop</param>
        /// <param name="initialise">If true, messages that initialise loops are reset when observed values change</param>
        private void Execute(int numberOfIterations, bool initialise)
        {
            if (numberOfIterations < this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone)
            {
                this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised = false;
                this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = false;
                this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = false;
                this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
            }
            this.Changed_N();
            this.Changed_N_D();
            this.Changed_N_D_Q();
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6(initialise);
            this.Constant();
            this.Changed_D_Q();
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8(initialise);
            this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2(initialise);
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0(numberOfIterations);
            this.numberOfIterationsDone = numberOfIterations;
        }

        public void Execute(int numberOfIterations)
        {
            this.Execute(numberOfIterations, true);
        }

        public void Update(int additionalIterations)
        {
            this.Execute(this.numberOfIterationsDone + additionalIterations, false);
        }

        private void OnProgressChanged(ProgressChangedEventArgs e)
        {
            // Make a temporary copy of the event to avoid a race condition
            // if the last subscriber unsubscribes immediately after the null check and before the event is raised.
            EventHandler<ProgressChangedEventArgs> handler = this.ProgressChanged;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        /// <summary>Reset all messages to their initial values.  Sets NumberOfIterationsDone to 0.</summary>
        public void Reset()
        {
            this.Execute(0);
        }

        /// <summary>Computations that depend on the observed value of N</summary>
        public void Changed_N()
        {
            if (this.Changed_N_iterationsDone == 1)
            {
                return;
            }
            // Create array for replicates of 'temp_B'
            this.temp_B = new DistributionStructArray<Gaussian, double>[this.n][];
            this.Changed_N_iterationsDone = 1;
            this.Changed_N_D_iterationsDone = 0;
            this.Changed_N_D_Q_iterationsDone = 0;
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of N and D</summary>
        public void Changed_N_D()
        {
            if (this.Changed_N_D_iterationsDone == 1)
            {
                return;
            }
            for (int n = 0; n < N; n++)
            {
                // Create array for replicates of 'temp_B'
                this.temp_B[n] = new DistributionStructArray<Gaussian, double>[this.d];
            }
            this.Changed_N_D_iterationsDone = 1;
            this.Changed_N_D_Q_iterationsDone = 0;
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of N and D and Q</summary>
        public void Changed_N_D_Q()
        {
            if (this.Changed_N_D_Q_iterationsDone == 1)
            {
                return;
            }
            for (int n = 0; n < N; n++)
            {
                for (int d = 0; d < D; d++)
                {
                    // Create array for 'temp' Backwards messages.
                    this.temp_B[n][d] = new DistributionStructArray<Gaussian, double>(this.q);
                }
            }
            this.Changed_N_D_Q_iterationsDone = 1;
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of N and D and Q and must reset on changes to numberOfIterationsDecreased and observedData and noisePrecisionPrior and K_node_inverse and nodeSignalPrecisionsPrior and nodeFunctionsInitVar and K_weights_inverse</summary>
        /// <param name="initialise">If true, reset messages that initialise loops</param>
        public void Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6(bool initialise)
        {
            if ((this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone == 1) && ((!initialise) || this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised))
            {
                return;
            }
            for (int n = 0; n < N; n++)
            {
                for (int d = 0; d < D; d++)
                {
                    for (int q = 0; q < Q; q++)
                    {
                        this.temp_B[n][d][q] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_iterationsDone = 1;
            this.Changed_N_D_Q_Init_numberOfIterationsDecreased_observedData_noisePrecisionPrior_K_node_inverse_nodeS6_isInitialised = true;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
        }

        /// <summary>Computations that do not depend on observed values</summary>
        public void Constant()
        {
            if (this.Constant_iterationsDone == 1)
            {
                return;
            }
            this.Constant_iterationsDone = 1;
            this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
            this.Changed_D_Q_iterationsDone = 0;
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of D and Q</summary>
        public void Changed_D_Q()
        {
            if (this.Changed_D_Q_iterationsDone == 1)
            {
                return;
            }
            // Create array for 'weightFunctions_use' Backwards messages.
            this.weightFunctions_use_B = new DistributionRefArray2D<VectorGaussian, Vector>(this.d, this.q);
            this.Changed_D_Q_iterationsDone = 1;
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_iterationsDone = 0;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of D and Q and must reset on changes to numberOfIterationsDecreased and N and observedData and noisePrecisionPrior and K_node_inverse and nodeSignalPrecisionsPrior and nodeFunctionsInitVar and K_weights_inverse</summary>
        /// <param name="initialise">If true, reset messages that initialise loops</param>
        public void Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8(bool initialise)
        {
            if ((this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_iterationsDone == 1) && ((!initialise) || this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised))
            {
                return;
            }
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    this.weightFunctions_use_B[d, q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
                }
            }
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_iterationsDone = 1;
            this.Changed_D_Q_Init_numberOfIterationsDecreased_N_observedData_noisePrecisionPrior_K_node_inverse_nodeS8_isInitialised = true;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of nodeFunctionsInitVar and must reset on changes to numberOfIterationsDecreased and Q and N and D and observedData and noisePrecisionPrior and K_node_inverse and nodeSignalPrecisionsPrior and K_weights_inverse</summary>
        /// <param name="initialise">If true, reset messages that initialise loops</param>
        public void Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2(bool initialise)
        {
            if ((this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_iterationsDone == 1) && ((!initialise) || this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised))
            {
                return;
            }
            // Create array for 'nodeFunctions_marginal' Forwards messages.
            this.nodeFunctions_marginal_F = ArrayHelper.MakeCopy<DistributionRefArray<VectorGaussian, Vector>>((DistributionRefArray<VectorGaussian, Vector>)this.NodeFunctionsInitVar);
            // Create array for 'nodeFunctions_use' Forwards messages.
            this.nodeFunctions_use_F = ArrayHelper.MakeCopy<DistributionRefArray<VectorGaussian, Vector>>((DistributionRefArray<VectorGaussian, Vector>)this.NodeFunctionsInitVar);
            this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_iterationsDone = 1;
            this.Changed_nodeFunctionsInitVar_Init_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior2_isInitialised = true;
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = 0;
        }

        /// <summary>Computations that depend on the observed value of numberOfIterationsDecreased and Q and N and D and observedData and noisePrecisionPrior and K_node_inverse and nodeSignalPrecisionsPrior and nodeFunctionsInitVar and K_weights_inverse</summary>
        /// <param name="numberOfIterations">The number of times to iterate each loop</param>
        public void Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0(int numberOfIterations)
        {
            if (this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone == numberOfIterations)
            {
                return;
            }
            // The constant 'vBernoulli0'
            Bernoulli vBernoulli0 = Bernoulli.FromLogOdds(0);
            this.ev_marginal_F = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
            // Buffer for VectorGaussianScaledPrecisionOp.SampleMean
            // Create array for replicates of 'nodeFunctions_B_q__SampleVariance'
            PositiveDefiniteMatrix[] nodeFunctions_B_q__SampleVariance = new PositiveDefiniteMatrix[this.q];
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep2_uses' from VectorGaussianScaled factor
                nodeFunctions_B_q__SampleVariance[q] = VectorGaussianScaledPrecisionOp.SampleVarianceInit(this.nodeFunctions_marginal_F[q]);
            }
            // Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
            // Create array for replicates of 'nodeFunctions_B_q__SampleMean'
            Vector[] nodeFunctions_B_q__SampleMean = new Vector[this.q];
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep2_uses' from VectorGaussianScaled factor
                nodeFunctions_B_q__SampleMean[q] = VectorGaussianScaledPrecisionOp.SampleMeanInit(this.nodeFunctions_marginal_F[q]);
            }
            // Message from use of 'nodeSignalPrecisions'
            DistributionStructArray<Gamma, double> nodeSignalPrecisions_use_B = default(DistributionStructArray<Gamma, double>);
            // Create array for 'nodeSignalPrecisions_use' Backwards messages.
            nodeSignalPrecisions_use_B = new DistributionStructArray<Gamma, double>(this.q);
            for (int q = 0; q < Q; q++)
            {
                nodeSignalPrecisions_use_B[q] = ArrayHelper.MakeUniform<Gamma>(this.NodeSignalPrecisionsPrior);
            }
            // Create array for 'nodeSignalPrecisions_marginal' Forwards messages.
            this.nodeSignalPrecisions_marginal_F = new DistributionStructArray<Gamma, double>(this.q);
            for (int q = 0; q < Q; q++)
            {
                this.nodeSignalPrecisions_marginal_F[q] = ArrayHelper.MakeUniform<Gamma>(this.NodeSignalPrecisionsPrior);
            }
            DistributionRefArray<VectorGaussian, Vector> nodeFunctions_F = default(DistributionRefArray<VectorGaussian, Vector>);
            // Create array for 'nodeFunctions' Forwards messages.
            nodeFunctions_F = new DistributionRefArray<VectorGaussian, Vector>(this.q);
            for (int q = 0; q < Q; q++)
            {
                nodeFunctions_F[q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
            }
            VectorGaussian _hoist4 = default(VectorGaussian);
            DistributionRefArray2D<VectorGaussian, Vector> weightFunctions_F = default(DistributionRefArray2D<VectorGaussian, Vector>);
            // Create array for 'weightFunctions' Forwards messages.
            weightFunctions_F = new DistributionRefArray2D<VectorGaussian, Vector>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    weightFunctions_F[d, q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
                }
            }
            for (int q = 0; q < Q; q++)
            {
                for (int d = 0; d < D; d++)
                {
                    _hoist4 = ArrayHelper.CopyStorage<VectorGaussian>(weightFunctions_F[d, q]);
                    q = this.q - 1;
                    d = this.d - 1;
                }
            }
            _hoist4 = VectorGaussianScaledPrecisionOp.SampleAverageLogarithm(1, this.k_weights_inverse, _hoist4);
            this.noisePrecision_marginal_F = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
            // Create array for replicates of 'sum_B'
            Gaussian[][] sum_B = new Gaussian[this.n][];
            for (int n = 0; n < N; n++)
            {
                // Create array for replicates of 'sum_B'
                sum_B[n] = new Gaussian[this.d];
                for (int d = 0; d < D; d++)
                {
                    sum_B[n][d] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
            }
            // Create array for replicates of 'temp_F'
            DistributionStructArray<Gaussian, double>[][] temp_F = new DistributionStructArray<Gaussian, double>[this.n][];
            for (int n = 0; n < N; n++)
            {
                // Create array for replicates of 'temp_F'
                temp_F[n] = new DistributionStructArray<Gaussian, double>[this.d];
                for (int d = 0; d < D; d++)
                {
                    // Create array for 'temp' Forwards messages.
                    temp_F[n][d] = new DistributionStructArray<Gaussian, double>(this.q);
                    for (int q = 0; q < Q; q++)
                    {
                        temp_F[n][d][q] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            // Create array for 'nodeFunctionValues' Forwards messages.
            this.nodeFunctionValues_F = new DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]>(this.q);
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'nodeFunctionValues' Forwards messages.
                this.nodeFunctionValues_F[q] = new DistributionStructArray<Gaussian, double>(this.n);
                for (int _iv0 = 0; _iv0 < N; _iv0++)
                {
                    this.nodeFunctionValues_F[q][_iv0] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
            }
            // Message from use of 'weightFunctionValues'
            DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]> weightFunctionValues_use_B = default(DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]>);
            // Create array for 'weightFunctionValues_use' Backwards messages.
            weightFunctionValues_use_B = new DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    // Create array for 'weightFunctionValues_use' Backwards messages.
                    weightFunctionValues_use_B[d, q] = new DistributionStructArray<Gaussian, double>(this.n);
                    for (int _iv2 = 0; _iv2 < N; _iv2++)
                    {
                        weightFunctionValues_use_B[d, q][_iv2] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            // Messages from use of 'weightFunctions'
            DistributionRefArray2D<VectorGaussian, Vector>[] weightFunctions_use_uses_B = default(DistributionRefArray2D<VectorGaussian, Vector>[]);
            // Create array for 'weightFunctions_use_uses' Backwards messages.
            weightFunctions_use_uses_B = new DistributionRefArray2D<VectorGaussian, Vector>[2];
            for (int _ind = 0; _ind < 2; _ind++)
            {
                // Create array for 'weightFunctions_use_uses' Backwards messages.
                weightFunctions_use_uses_B[_ind] = new DistributionRefArray2D<VectorGaussian, Vector>(this.d, this.q);
                for (int d = 0; d < D; d++)
                {
                    for (int q = 0; q < Q; q++)
                    {
                        weightFunctions_use_uses_B[_ind][d, q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
                    }
                }
            }
            // Message to marginal of 'weightFunctions'
            DistributionRefArray2D<VectorGaussian, Vector> weightFunctions_marginal_F = default(DistributionRefArray2D<VectorGaussian, Vector>);
            // Create array for 'weightFunctions_marginal' Forwards messages.
            weightFunctions_marginal_F = new DistributionRefArray2D<VectorGaussian, Vector>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    weightFunctions_marginal_F[d, q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
                }
            }
            // Create array for 'weightFunctionValues' Forwards messages.
            this.weightFunctionValues_F = new DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    // Create array for 'weightFunctionValues' Forwards messages.
                    this.weightFunctionValues_F[d, q] = new DistributionStructArray<Gaussian, double>(this.n);
                    for (int _iv2 = 0; _iv2 < N; _iv2++)
                    {
                        this.weightFunctionValues_F[d, q][_iv2] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            // Create array for replicates of 'nodeFunctionValues_rep0_B'
            DistributionStructArray<Gaussian, double>[][] nodeFunctionValues_rep0_B = new DistributionStructArray<Gaussian, double>[this.q][];
            for (int q = 0; q < Q; q++)
            {
                // Create array for replicates of 'nodeFunctionValues_rep0_B'
                nodeFunctionValues_rep0_B[q] = new DistributionStructArray<Gaussian, double>[this.n];
                for (int n = 0; n < N; n++)
                {
                    // Create array for 'nodeFunctionValues_rep0' Backwards messages.
                    nodeFunctionValues_rep0_B[q][n] = new DistributionStructArray<Gaussian, double>(this.d);
                    for (int d = 0; d < D; d++)
                    {
                        nodeFunctionValues_rep0_B[q][n][d] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                }
            }
            // Message from use of 'nodeFunctionValues'
            DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]> nodeFunctionValues_use_B = default(DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]>);
            // Create array for 'nodeFunctionValues_use' Backwards messages.
            nodeFunctionValues_use_B = new DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]>(this.q);
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'nodeFunctionValues_use' Backwards messages.
                nodeFunctionValues_use_B[q] = new DistributionStructArray<Gaussian, double>(this.n);
                for (int _iv0 = 0; _iv0 < N; _iv0++)
                {
                    nodeFunctionValues_use_B[q][_iv0] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
            }
            // Messages from use of 'nodeFunctions'
            DistributionRefArray<VectorGaussian, Vector>[] nodeFunctions_use_uses_B = default(DistributionRefArray<VectorGaussian, Vector>[]);
            // Create array for 'nodeFunctions_use_uses' Backwards messages.
            nodeFunctions_use_uses_B = new DistributionRefArray<VectorGaussian, Vector>[2];
            for (int _ind = 0; _ind < 2; _ind++)
            {
                // Create array for 'nodeFunctions_use_uses' Backwards messages.
                nodeFunctions_use_uses_B[_ind] = new DistributionRefArray<VectorGaussian, Vector>(this.q);
                for (int q = 0; q < Q; q++)
                {
                    nodeFunctions_use_uses_B[_ind][q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
                }
            }
            // Message from use of 'nodeFunctions'
            DistributionRefArray<VectorGaussian, Vector> nodeFunctions_use_B = default(DistributionRefArray<VectorGaussian, Vector>);
            // Create array for 'nodeFunctions_use' Backwards messages.
            nodeFunctions_use_B = new DistributionRefArray<VectorGaussian, Vector>(this.q);
            for (int q = 0; q < Q; q++)
            {
                nodeFunctions_use_B[q] = ArrayHelper.MakeUniform<VectorGaussian>(VectorGaussian.Uniform(N));
            }
            // Create array for replicates of 'sum_F'
            Gaussian[][] sum_F = new Gaussian[this.n][];
            for (int n = 0; n < N; n++)
            {
                // Create array for replicates of 'sum_F'
                sum_F[n] = new Gaussian[this.d];
                for (int d = 0; d < D; d++)
                {
                    sum_F[n][d] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
            }
            // Create array for replicates of 'noisePrecision_rep0_rep0_B'
            DistributionStructArray<Gamma, double>[] noisePrecision_rep0_rep0_B = new DistributionStructArray<Gamma, double>[this.n];
            for (int n = 0; n < N; n++)
            {
                // Create array for 'noisePrecision_rep0_rep0' Backwards messages.
                noisePrecision_rep0_rep0_B[n] = new DistributionStructArray<Gamma, double>(this.d);
                for (int d = 0; d < D; d++)
                {
                    noisePrecision_rep0_rep0_B[n][d] = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
                }
            }
            DistributionStructArray<Gamma, double> noisePrecision_rep0_B = default(DistributionStructArray<Gamma, double>);
            // Create array for 'noisePrecision_rep0' Backwards messages.
            noisePrecision_rep0_B = new DistributionStructArray<Gamma, double>(this.n);
            for (int n = 0; n < N; n++)
            {
                noisePrecision_rep0_B[n] = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
            }
            // Message from use of 'noisePrecision'
            Gamma noisePrecision_use_B = ArrayHelper.MakeUniform<Gamma>(this.NoisePrecisionPrior);
            for (int q = 0; q < Q; q++)
            {
                for (int d = 0; d < D; d++)
                {
                    // Message to 'weightFunctions_marginal' from Variable factor
                    weightFunctions_marginal_F[d, q] = VariableVmpOp.MarginalAverageLogarithm<VectorGaussian>(this.weightFunctions_use_B[d, q], _hoist4, weightFunctions_marginal_F[d, q]);
                    // Message to 'weightFunctionValues' from ArrayFromVector factor
                    this.weightFunctionValues_F[d, q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(weightFunctions_marginal_F[d, q], this.weightFunctionValues_F[d, q]);
                }
            }
            for (int iteration = this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone; iteration < numberOfIterations; iteration++)
            {
                for (int q = 0; q < Q; q++)
                {
                    // Message to 'nodeFunctionValues' from ArrayFromVector factor
                    this.nodeFunctionValues_F[q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(this.nodeFunctions_use_F[q], this.nodeFunctionValues_F[q]);
                    for (int n = 0; n < N; n++)
                    {
                        for (int d = 0; d < D; d++)
                        {
                            // Message to 'temp' from Product factor
                            temp_F[n][d][q] = GaussianProductVmpOp.ProductAverageLogarithm(this.weightFunctionValues_F[d, q][n], this.nodeFunctionValues_F[q][n]);
                        }
                    }
                }
                for (int n = 0; n < N; n++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'sum' from Sum factor
                        sum_F[n][d] = FastSumOp.SumAverageLogarithm(temp_F[n][d]);
                        // Message to 'noisePrecision_rep0_rep0' from Gaussian factor
                        noisePrecision_rep0_rep0_B[n][d] = GaussianOp.PrecisionAverageLogarithm(this.ObservedData[d, n], sum_F[n][d]);
                    }
                    // Message to 'noisePrecision_rep0' from Replicate factor
                    noisePrecision_rep0_B[n] = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep0_rep0_B[n], noisePrecision_rep0_B[n]);
                }
                // Message to 'noisePrecision_use' from Replicate factor
                noisePrecision_use_B = ReplicateOp.DefAverageLogarithm<Gamma>(noisePrecision_rep0_B, noisePrecision_use_B);
                // Message to 'noisePrecision_marginal' from Variable factor
                this.noisePrecision_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Gamma>(noisePrecision_use_B, this.NoisePrecisionPrior, this.noisePrecision_marginal_F);
                for (int n = 0; n < N; n++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'sum' from Gaussian factor
                        sum_B[n][d] = GaussianOp.MeanAverageLogarithm(this.ObservedData[d, n], this.noisePrecision_marginal_F);
                        // Message to 'temp' from Sum factor
                        this.temp_B[n][d] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(sum_B[n][d], temp_F[n][d], this.temp_B[n][d]);
                        for (int q = 0; q < Q; q++)
                        {
                            // Message to 'weightFunctionValues_use' from Product factor
                            weightFunctionValues_use_B[d, q][n] = GaussianProductVmpOp.AAverageLogarithm(this.temp_B[n][d][q], this.nodeFunctionValues_F[q][n]);
                        }
                    }
                }
                for (int q = 0; q < Q; q++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'weightFunctions_use_uses' from ArrayFromVector factor
                        weightFunctions_use_uses_B[0][d, q] = ArrayFromVectorOp.VectorAverageLogarithm(weightFunctionValues_use_B[d, q], weightFunctions_use_uses_B[0][d, q]);
                    }
                }
                // Message to 'weightFunctions_use' from Replicate factor
                this.weightFunctions_use_B = ReplicateOp.DefAverageLogarithm<DistributionRefArray2D<VectorGaussian, Vector>>(weightFunctions_use_uses_B, this.weightFunctions_use_B);
                for (int q = 0; q < Q; q++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'weightFunctions_marginal' from Variable factor
                        weightFunctions_marginal_F[d, q] = VariableVmpOp.MarginalAverageLogarithm<VectorGaussian>(this.weightFunctions_use_B[d, q], _hoist4, weightFunctions_marginal_F[d, q]);
                        // Message to 'weightFunctionValues' from ArrayFromVector factor
                        this.weightFunctionValues_F[d, q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(weightFunctions_marginal_F[d, q], this.weightFunctionValues_F[d, q]);
                        for (int n = 0; n < N; n++)
                        {
                            // Message to 'temp' from Product factor
                            temp_F[n][d][q] = GaussianProductVmpOp.ProductAverageLogarithm(this.weightFunctionValues_F[d, q][n], this.nodeFunctionValues_F[q][n]);
                        }
                    }
                }
                for (int n = 0; n < N; n++)
                {
                    for (int d = 0; d < D; d++)
                    {
                        // Message to 'temp' from Sum factor
                        this.temp_B[n][d] = FastSumOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(sum_B[n][d], temp_F[n][d], this.temp_B[n][d]);
                        for (int q = 0; q < Q; q++)
                        {
                            // Message to 'nodeFunctionValues_rep0' from Product factor
                            nodeFunctionValues_rep0_B[q][n][d] = GaussianProductVmpOp.BAverageLogarithm(this.temp_B[n][d][q], this.weightFunctionValues_F[d, q][n]);
                        }
                    }
                    for (int q = 0; q < Q; q++)
                    {
                        // Message to 'nodeFunctionValues_use' from Replicate factor
                        nodeFunctionValues_use_B[q][n] = ReplicateOp.DefAverageLogarithm<Gaussian>(nodeFunctionValues_rep0_B[q][n], nodeFunctionValues_use_B[q][n]);
                    }
                }
                for (int q = 0; q < Q; q++)
                {
                    // Message to 'nodeFunctions_use_uses' from ArrayFromVector factor
                    nodeFunctions_use_uses_B[0][q] = ArrayFromVectorOp.VectorAverageLogarithm(nodeFunctionValues_use_B[q], nodeFunctions_use_uses_B[0][q]);
                }
                // Message to 'nodeFunctions_use' from Replicate factor
                nodeFunctions_use_B = ReplicateOp.DefAverageLogarithm<DistributionRefArray<VectorGaussian, Vector>>(nodeFunctions_use_uses_B, nodeFunctions_use_B);
                for (int q = 0; q < Q; q++)
                {
                    // Message to 'ev_selector_cases_0_rep2_uses' from VectorGaussianScaled factor
                    nodeFunctions_B_q__SampleVariance[q] = VectorGaussianScaledPrecisionOp.SampleVariance(this.nodeFunctions_marginal_F[q], nodeFunctions_B_q__SampleVariance[q]);
                    // Message to 'ev_selector_cases_0_rep2_uses' from VectorGaussianScaled factor
                    nodeFunctions_B_q__SampleMean[q] = VectorGaussianScaledPrecisionOp.SampleMean(this.nodeFunctions_marginal_F[q], nodeFunctions_B_q__SampleVariance[q], nodeFunctions_B_q__SampleMean[q]);
                    // Message to 'nodeSignalPrecisions_use' from VectorGaussianScaled factor
                    nodeSignalPrecisions_use_B[q] = VectorGaussianScaledPrecisionOp.ScalingAverageLogarithm(this.k_node_inverse, nodeFunctions_B_q__SampleMean[q], nodeFunctions_B_q__SampleVariance[q]);
                    // Message to 'nodeSignalPrecisions_marginal' from Variable factor
                    this.nodeSignalPrecisions_marginal_F[q] = VariableVmpOp.MarginalAverageLogarithm<Gamma>(nodeSignalPrecisions_use_B[q], this.NodeSignalPrecisionsPrior, this.nodeSignalPrecisions_marginal_F[q]);
                    // Message to 'nodeFunctions' from VectorGaussianScaled factor
                    nodeFunctions_F[q] = VectorGaussianScaledPrecisionOp.SampleAverageLogarithm(this.nodeSignalPrecisions_marginal_F[q], this.k_node_inverse, nodeFunctions_F[q]);
                    // Message to 'nodeFunctions_marginal' from Variable factor
                    this.nodeFunctions_marginal_F[q] = VariableVmpOp.MarginalAverageLogarithm<VectorGaussian>(nodeFunctions_use_B[q], nodeFunctions_F[q], this.nodeFunctions_marginal_F[q]);
                    // Message to 'nodeFunctions_use' from Variable factor
                    this.nodeFunctions_use_F[q] = Factor.Copy<VectorGaussian>(this.nodeFunctions_marginal_F[q]);
                }
                this.OnProgressChanged(new ProgressChangedEventArgs(iteration));
            }
            Bernoulli[] ev_selector_cases_0_uses_B = default(Bernoulli[]);
            // Create array for 'ev_selector_cases_0_uses' Backwards messages.
            ev_selector_cases_0_uses_B = new Bernoulli[46];
            for (int _ind = 0; _ind < 46; _ind++)
            {
                ev_selector_cases_0_uses_B[_ind] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            }
            // Message to 'ev_selector_cases_0_uses' from Random factor
            ev_selector_cases_0_uses_B[3] = Bernoulli.FromLogOdds(UnaryOp<double>.AverageLogFactor<Gamma>(this.noisePrecision_marginal_F, this.NoisePrecisionPrior));
            // Message to 'ev_selector_cases_0_uses' from Variable factor
            ev_selector_cases_0_uses_B[4] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gamma>(this.noisePrecision_marginal_F, this.NoisePrecisionPrior));
            DistributionStructArray<Bernoulli, bool>[] ev_selector_cases_0_rep1_uses_B = default(DistributionStructArray<Bernoulli, bool>[]);
            // Create array for 'ev_selector_cases_0_rep1_uses' Backwards messages.
            ev_selector_cases_0_rep1_uses_B = new DistributionStructArray<Bernoulli, bool>[2];
            for (int _ind = 0; _ind < 2; _ind++)
            {
                // Create array for 'ev_selector_cases_0_rep1_uses' Backwards messages.
                ev_selector_cases_0_rep1_uses_B[_ind] = new DistributionStructArray<Bernoulli, bool>(this.q);
                for (int q = 0; q < Q; q++)
                {
                    ev_selector_cases_0_rep1_uses_B[_ind][q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                }
            }
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep1_uses' from Random factor
                ev_selector_cases_0_rep1_uses_B[0][q] = Bernoulli.FromLogOdds(UnaryOp<double>.AverageLogFactor<Gamma>(this.nodeSignalPrecisions_marginal_F[q], this.NodeSignalPrecisionsPrior));
                // Message to 'ev_selector_cases_0_rep1_uses' from Variable factor
                ev_selector_cases_0_rep1_uses_B[1][q] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<Gamma>(this.nodeSignalPrecisions_marginal_F[q], this.NodeSignalPrecisionsPrior));
            }
            DistributionStructArray<Bernoulli, bool> ev_selector_cases_0_rep1_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases_0_rep1' Backwards messages.
            ev_selector_cases_0_rep1_B = new DistributionStructArray<Bernoulli, bool>(this.q);
            for (int q = 0; q < Q; q++)
            {
                ev_selector_cases_0_rep1_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            }
            // Message to 'ev_selector_cases_0_rep1' from Replicate factor
            ev_selector_cases_0_rep1_B = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli, bool>>(ev_selector_cases_0_rep1_uses_B, ev_selector_cases_0_rep1_B);
            // Message to 'ev_selector_cases_0_uses' from Replicate factor
            ev_selector_cases_0_uses_B[9] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep1_B, ev_selector_cases_0_uses_B[9]);
            double _hoist0 = default(double);
            _hoist0 = VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(this.k_node_inverse);
            // Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
            // Create array for replicates of 'nodeFunctions_B_q__SampleMean_ESamplePrecisionSample'
            double[] nodeFunctions_B_q__SampleMean_ESamplePrecisionSample = new double[this.q];
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep2_uses' from VectorGaussianScaled factor
                nodeFunctions_B_q__SampleMean_ESamplePrecisionSample[q] = VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(nodeFunctions_B_q__SampleMean[q], nodeFunctions_B_q__SampleVariance[q], this.k_node_inverse);
            }
            DistributionStructArray<Bernoulli, bool>[] ev_selector_cases_0_rep2_uses_B = default(DistributionStructArray<Bernoulli, bool>[]);
            // Create array for 'ev_selector_cases_0_rep2_uses' Backwards messages.
            ev_selector_cases_0_rep2_uses_B = new DistributionStructArray<Bernoulli, bool>[2];
            for (int _ind = 0; _ind < 2; _ind++)
            {
                // Create array for 'ev_selector_cases_0_rep2_uses' Backwards messages.
                ev_selector_cases_0_rep2_uses_B[_ind] = new DistributionStructArray<Bernoulli, bool>(this.q);
                for (int q = 0; q < Q; q++)
                {
                    ev_selector_cases_0_rep2_uses_B[_ind][q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                }
            }
            double L_K_node = 0.0; 
            for (int q = 0; q < Q; q++)
            {
                // Message to 'ev_selector_cases_0_rep2_uses' from VectorGaussianScaled factor
                double temp = VectorGaussianScaledPrecisionOp.AverageLogFactor(nodeFunctions_B_q__SampleMean[q], this.nodeSignalPrecisions_marginal_F[q], nodeFunctions_B_q__SampleMean_ESamplePrecisionSample[q], _hoist0);
                ev_selector_cases_0_rep2_uses_B[0][q] = Bernoulli.FromLogOdds(temp);
                L_K_node += temp; 
                // Message to 'ev_selector_cases_0_rep2_uses' from Variable factor
                ev_selector_cases_0_rep2_uses_B[1][q] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<VectorGaussian>(this.nodeFunctions_marginal_F[q], nodeFunctions_F[q]));
            }

            this.nodeKernelOptimiser.Optimise((prec, gradK, gradientVector) =>
                KernelOptimiser.mlfHelperNode(prec, gradK, gradientVector, nodeFunctions_B_q__SampleMean,
                nodeFunctions_B_q__SampleVariance, this.nodeSignalPrecisions_marginal_F), ref this.k_node_inverse);

            DistributionStructArray<Bernoulli, bool> ev_selector_cases_0_rep2_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases_0_rep2' Backwards messages.
            ev_selector_cases_0_rep2_B = new DistributionStructArray<Bernoulli, bool>(this.q);
            for (int q = 0; q < Q; q++)
            {
                ev_selector_cases_0_rep2_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            }
            // Message to 'ev_selector_cases_0_rep2' from Replicate factor
            ev_selector_cases_0_rep2_B = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli, bool>>(ev_selector_cases_0_rep2_uses_B, ev_selector_cases_0_rep2_B);
            // Message to 'ev_selector_cases_0_uses' from Replicate factor
            ev_selector_cases_0_uses_B[12] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep2_B, ev_selector_cases_0_uses_B[12]);
            double _hoist3 = default(double);
            _hoist3 = VectorGaussianScaledPrecisionOp.PrecisionMeanLogDet(this.k_weights_inverse);
            // Buffer for VectorGaussianScaledPrecisionOp.SampleMean
            // Create array for replicates of 'weightFunctions_B_d__q__SampleVariance'
            PositiveDefiniteMatrix[][] weightFunctions_B_d__q__SampleVariance = new PositiveDefiniteMatrix[this.q][];
            for (int q = 0; q < Q; q++)
            {
                // Create array for replicates of 'weightFunctions_B_d__q__SampleVariance'
                weightFunctions_B_d__q__SampleVariance[q] = new PositiveDefiniteMatrix[this.d];
                for (int d = 0; d < D; d++)
                {
                    // Message to 'ev_selector_cases_0_rep7_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleVariance[q][d] = VectorGaussianScaledPrecisionOp.SampleVarianceInit(weightFunctions_marginal_F[d, q]);
                    // Message to 'ev_selector_cases_0_rep7_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleVariance[q][d] = VectorGaussianScaledPrecisionOp.SampleVariance(weightFunctions_marginal_F[d, q], weightFunctions_B_d__q__SampleVariance[q][d]);
                }
            }
            // Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
            // Create array for replicates of 'weightFunctions_B_d__q__SampleMean'
            Vector[][] weightFunctions_B_d__q__SampleMean = new Vector[this.q][];
            for (int q = 0; q < Q; q++)
            {
                // Create array for replicates of 'weightFunctions_B_d__q__SampleMean'
                weightFunctions_B_d__q__SampleMean[q] = new Vector[this.d];
                for (int d = 0; d < D; d++)
                {
                    // Message to 'ev_selector_cases_0_rep7_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleMean[q][d] = VectorGaussianScaledPrecisionOp.SampleMeanInit(weightFunctions_marginal_F[d, q]);
                    // Message to 'ev_selector_cases_0_rep7_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleMean[q][d] = VectorGaussianScaledPrecisionOp.SampleMean(weightFunctions_marginal_F[d, q], weightFunctions_B_d__q__SampleVariance[q][d], weightFunctions_B_d__q__SampleMean[q][d]);
                }
            }
            // Buffer for VectorGaussianScaledPrecisionOp.AverageLogFactor
            // Create array for replicates of 'weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample'
            double[][] weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample = new double[this.q][];
            for (int q = 0; q < Q; q++)
            {
                // Create array for replicates of 'weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample'
                weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample[q] = new double[this.d];
                for (int d = 0; d < D; d++)
                {
                    // Message to 'ev_selector_cases_0_rep7_rep0_uses' from VectorGaussianScaled factor
                    weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample[q][d] = VectorGaussianScaledPrecisionOp.ESamplePrecisionSample(weightFunctions_B_d__q__SampleMean[q][d], weightFunctions_B_d__q__SampleVariance[q][d], this.k_weights_inverse);
                }
            }
            // Create array for replicates of 'ev_selector_cases_0_rep7_rep0_uses_B'
            DistributionStructArray<Bernoulli, bool>[][] ev_selector_cases_0_rep7_rep0_uses_B = new DistributionStructArray<Bernoulli, bool>[this.q][];
            double L_K_weight = 0.0; 
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'ev_selector_cases_0_rep7_rep0_uses' Backwards messages.
                ev_selector_cases_0_rep7_rep0_uses_B[q] = new DistributionStructArray<Bernoulli, bool>[2];
                for (int _ind = 0; _ind < 2; _ind++)
                {
                    // Create array for 'ev_selector_cases_0_rep7_rep0_uses' Backwards messages.
                    ev_selector_cases_0_rep7_rep0_uses_B[q][_ind] = new DistributionStructArray<Bernoulli, bool>(this.d);
                    for (int d = 0; d < D; d++)
                    {
                        ev_selector_cases_0_rep7_rep0_uses_B[q][_ind][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                    }
                }
                for (int d = 0; d < D; d++)
                {
                    // Message to 'ev_selector_cases_0_rep7_rep0_uses' from VectorGaussianScaled factor
                    double temp = VectorGaussianScaledPrecisionOp.AverageLogFactor(weightFunctions_B_d__q__SampleMean[q][d], 1, weightFunctions_B_d__q__SampleMean_ESamplePrecisionSample[q][d], _hoist3); 
                    ev_selector_cases_0_rep7_rep0_uses_B[q][0][d] = Bernoulli.FromLogOdds(temp);
                    L_K_weight += temp; 
                    // Message to 'ev_selector_cases_0_rep7_rep0_uses' from Variable factor
                    ev_selector_cases_0_rep7_rep0_uses_B[q][1][d] = Bernoulli.FromLogOdds(VariableVmpOp.AverageLogFactor<VectorGaussian>(weightFunctions_marginal_F[d, q], _hoist4));
                }
            }

             this.weightKernelOptimiser.Optimise((prec, gradK, gradientVector) =>
                 KernelOptimiser.mlfHelperWeight(prec, gradK, gradientVector, weightFunctions_B_d__q__SampleMean,
                 weightFunctions_B_d__q__SampleVariance), ref this.k_weights_inverse);

            // Create array for replicates of 'ev_selector_cases_0_rep7_rep0_B'
            DistributionStructArray<Bernoulli, bool>[] ev_selector_cases_0_rep7_rep0_B = new DistributionStructArray<Bernoulli, bool>[this.q];
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'ev_selector_cases_0_rep7_rep0' Backwards messages.
                ev_selector_cases_0_rep7_rep0_B[q] = new DistributionStructArray<Bernoulli, bool>(this.d);
                for (int d = 0; d < D; d++)
                {
                    ev_selector_cases_0_rep7_rep0_B[q][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                }
                // Message to 'ev_selector_cases_0_rep7_rep0' from Replicate factor
                ev_selector_cases_0_rep7_rep0_B[q] = ReplicateOp.DefAverageLogarithm<DistributionStructArray<Bernoulli, bool>>(ev_selector_cases_0_rep7_rep0_uses_B[q], ev_selector_cases_0_rep7_rep0_B[q]);
            }
            DistributionStructArray<Bernoulli, bool> ev_selector_cases_0_rep7_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases_0_rep7' Backwards messages.
            ev_selector_cases_0_rep7_B = new DistributionStructArray<Bernoulli, bool>(this.q);
            for (int q = 0; q < Q; q++)
            {
                ev_selector_cases_0_rep7_B[q] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                // Message to 'ev_selector_cases_0_rep7' from Replicate factor
                ev_selector_cases_0_rep7_B[q] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep7_rep0_B[q], ev_selector_cases_0_rep7_B[q]);
            }
            // Message to 'ev_selector_cases_0_uses' from Replicate factor
            ev_selector_cases_0_uses_B[26] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep7_B, ev_selector_cases_0_uses_B[26]);
            // Create array for replicates of 'ev_selector_cases_0_rep16_rep0_B'
            DistributionStructArray<Bernoulli, bool>[] ev_selector_cases_0_rep16_rep0_B = new DistributionStructArray<Bernoulli, bool>[this.n];
            for (int n = 0; n < N; n++)
            {
                // Create array for 'ev_selector_cases_0_rep16_rep0' Backwards messages.
                ev_selector_cases_0_rep16_rep0_B[n] = new DistributionStructArray<Bernoulli, bool>(this.d);
                for (int d = 0; d < D; d++)
                {
                    ev_selector_cases_0_rep16_rep0_B[n][d] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                    // Message to 'ev_selector_cases_0_rep16_rep0' from Gaussian factor
                    ev_selector_cases_0_rep16_rep0_B[n][d] = Bernoulli.FromLogOdds(GaussianOp.AverageLogFactor(this.ObservedData[d, n], sum_F[n][d], this.noisePrecision_marginal_F));
                }
            }
            DistributionStructArray<Bernoulli, bool> ev_selector_cases_0_rep16_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases_0_rep16' Backwards messages.
            ev_selector_cases_0_rep16_B = new DistributionStructArray<Bernoulli, bool>(this.n);
            for (int n = 0; n < N; n++)
            {
                ev_selector_cases_0_rep16_B[n] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
                // Message to 'ev_selector_cases_0_rep16' from Replicate factor
                ev_selector_cases_0_rep16_B[n] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep16_rep0_B[n], ev_selector_cases_0_rep16_B[n]);
            }
            // Message to 'ev_selector_cases_0_uses' from Replicate factor
            ev_selector_cases_0_uses_B[42] = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_rep16_B, ev_selector_cases_0_uses_B[42]);
            Bernoulli ev_selector_cases_0_B = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            // Message to 'ev_selector_cases_0' from Replicate factor
            ev_selector_cases_0_B = ReplicateOp.DefAverageLogarithm<Bernoulli>(ev_selector_cases_0_uses_B, ev_selector_cases_0_B);
            DistributionStructArray<Bernoulli, bool> ev_selector_cases_B = default(DistributionStructArray<Bernoulli, bool>);
            // Create array for 'ev_selector_cases' Backwards messages.
            ev_selector_cases_B = new DistributionStructArray<Bernoulli, bool>(2);
            for (int _ind0 = 0; _ind0 < 2; _ind0++)
            {
                ev_selector_cases_B[_ind0] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
            }
            // Message to 'ev_selector_cases' from Copy factor
            ev_selector_cases_B[0] = Factor.Copy<Bernoulli>(ev_selector_cases_0_B);
            Bernoulli ev_selector_B = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
            // Message to 'ev_selector' from Cases factor
            ev_selector_B = CasesOp.BAverageLogarithm(ev_selector_cases_B);
            // Message to 'ev_marginal' from Variable factor
            this.ev_marginal_F = VariableVmpOp.MarginalAverageLogarithm<Bernoulli>(ev_selector_B, vBernoulli0, this.ev_marginal_F);
            // Create array for 'nodeFunctionValuesPredictive' Forwards messages.
            this.nodeFunctionValuesPredictive_F = new DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]>(this.q);
            for (int q = 0; q < Q; q++)
            {
                // Create array for 'nodeFunctionValuesPredictive' Forwards messages.
                this.nodeFunctionValuesPredictive_F[q] = new DistributionStructArray<Gaussian, double>(this.n);
                for (int _iv1 = 0; _iv1 < N; _iv1++)
                {
                    this.nodeFunctionValuesPredictive_F[q][_iv1] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                }
                // Message to 'nodeFunctionValuesPredictive' from ArrayFromVector factor
                this.nodeFunctionValuesPredictive_F[q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(this.nodeFunctions_use_F[q], this.nodeFunctionValuesPredictive_F[q]);
            }
            // Create array for 'weightFunctionValuesPredictive' Forwards messages.
            this.weightFunctionValuesPredictive_F = new DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]>(this.d, this.q);
            for (int d = 0; d < D; d++)
            {
                for (int q = 0; q < Q; q++)
                {
                    // Create array for 'weightFunctionValuesPredictive' Forwards messages.
                    this.weightFunctionValuesPredictive_F[d, q] = new DistributionStructArray<Gaussian, double>(this.n);
                    for (int _iv3 = 0; _iv3 < N; _iv3++)
                    {
                        this.weightFunctionValuesPredictive_F[d, q][_iv3] = ArrayHelper.MakeUniform<Gaussian>(new Gaussian());
                    }
                    // Message to 'weightFunctionValuesPredictive' from ArrayFromVector factor
                    this.weightFunctionValuesPredictive_F[d, q] = ArrayFromVectorOp.ArrayAverageLogarithm<DistributionStructArray<Gaussian, double>>(weightFunctions_marginal_F[d, q], this.weightFunctionValuesPredictive_F[d, q]);
                }
            }
            this.Changed_numberOfIterationsDecreased_Q_N_D_observedData_noisePrecisionPrior_K_node_inverse_nodeSignal0_iterationsDone = numberOfIterations;
        }

        /// <summary>
        /// Returns the marginal distribution for 'ev' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public Bernoulli EvMarginal()
        {
            return this.ev_marginal_F;
        }

        /// <summary>
        /// Returns the marginal distribution for 'noisePrecision' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public Gamma NoisePrecisionMarginal()
        {
            return this.noisePrecision_marginal_F;
        }

        /// <summary>
        /// Returns the marginal distribution for 'nodeSignalPrecisions' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public DistributionStructArray<Gamma, double> NodeSignalPrecisionsMarginal()
        {
            return this.nodeSignalPrecisions_marginal_F;
        }

        /// <summary>
        /// Returns the marginal distribution for 'nodeFunctionValues' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]> NodeFunctionValuesMarginal()
        {
            return this.nodeFunctionValues_F;
        }

        /// <summary>
        /// Returns the marginal distribution for 'nodeFunctionValuesPredictive' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public DistributionRefArray<DistributionStructArray<Gaussian, double>, double[]> NodeFunctionValuesPredictiveMarginal()
        {
            return this.nodeFunctionValuesPredictive_F;
        }

        /// <summary>
        /// Returns the marginal distribution for 'weightFunctionValues' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]> WeightFunctionValuesMarginal()
        {
            return this.weightFunctionValues_F;
        }

        /// <summary>
        /// Returns the marginal distribution for 'weightFunctionValuesPredictive' given by the current state of the
        /// message passing algorithm.
        /// </summary>
        /// <returns>The marginal distribution</returns>
        public DistributionRefArray2D<DistributionStructArray<Gaussian, double>, double[]> WeightFunctionValuesPredictiveMarginal()
        {
            return this.weightFunctionValuesPredictive_F;
        }

        #endregion

        #region Events
        /// <summary>Event that is fired when the progress of inference changes, typically at the end of one iteration of the inference algorithm.</summary>
        public event EventHandler<ProgressChangedEventArgs> ProgressChanged;
        #endregion

    }

}
